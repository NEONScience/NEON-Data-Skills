<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
<title>Download and Explore NEON Data</title>
<style type="text/css">
body {
  font-family: sans-serif;
  max-width: 800px;
  margin: auto;
  padding: 1em;
  line-height: 1.5;
  box-sizing: border-box;
}
body, .footnotes, code { font-size: .9em; }
li li { font-size: .95em; }
*, *:before, *:after {
  box-sizing: inherit;
}
pre, img { max-width: 100%; }
pre, pre:hover {
  white-space: pre-wrap;
  word-break: break-all;
}
pre code {
  display: block;
  overflow-x: auto;
}
code { font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace; }
:not(pre) > code, code[class] { background-color: #F8F8F8; }
code.language-undefined, pre > code:not([class]) {
  background-color: inherit;
  border: 1px solid #eee;
}
table {
  margin: auto;
  border-top: 1px solid #666;
}
table thead th { border-bottom: 1px solid #ddd; }
th, td { padding: 5px; }
thead, tfoot, tr:nth-child(even) { background: #eee; }
blockquote {
  color: #666;
  margin: 0;
  padding-left: 1em;
  border-left: 0.5em solid #eee;
}
hr, .footnotes::before { border: 1px dashed #ddd; }
.frontmatter { text-align: center; }
#TOC .numbered li { list-style: none; }
#TOC .numbered { padding-left: 0; }
#TOC .numbered ul { padding-left: 1em; }
table, .body h2 { border-bottom: 1px solid #666; }
.body .appendix, .appendix ~ h2 { border-bottom-style: dashed; }
.footnote-ref a::before { content: "["; }
.footnote-ref a::after { content: "]"; }
.footnotes::before {
  content: "";
  display: block;
  max-width: 20em;
}

@media print {
  body {
    font-size: 12pt;
    max-width: 100%;
  }
  tr, img { page-break-inside: avoid; }
}
@media only screen and (min-width: 992px) {
  pre { white-space: pre; }
}
</style>
</head>
<body>
<div class="include-before">
</div>
<div class="frontmatter">
<div class="title"><h1>Download and Explore NEON Data</h1></div>
<div class="author"><h2></h2></div>
<div class="date"><h3></h3></div>
</div>
<div class="body">
<p>This tutorial covers downloading NEON data, using the Data Portal and
the neonUtilities R package, as well as basic instruction in beginning to
explore and work with the downloaded data, including guidance in
navigating data documentation. We will explore data of 3 different types,
and make a simple figure from each.</p>
<h2 id="neon-data">NEON data</h2>
<p>There are 3 basic categories of NEON data:</p>
<ol>
<li>Remote sensing (AOP) - Data collected by the airborne observation platform,
e.g. LIDAR, surface reflectance</li>
<li>Observational (OS) - Data collected by a human in the field, or in an
analytical laboratory, e.g. beetle identification, foliar isotopes</li>
<li>Instrumentation (IS) - Data collected by an automated, streaming sensor, e.g.
net radiation, soil carbon dioxide. This category also includes the eddy
covariance (EC) data, which are processed and structured in a unique way, distinct
from other instrumentation data (see <a href="https://www.neonscience.org/eddy-data-intro" target="_blank">Tutorial for EC data</a> for details).</li>
</ol>
<p>This lesson covers all three types of data. The download procedures are
similar for all types, but data navigation differs significantly by type.</p>
<div id="ds-objectives" markdown="1">
<h2 id="objectives">Objectives</h2>
<p>After completing this activity, you will be able to:</p>
<ul>
<li>Download NEON data using the neonUtilities package.</li>
<li>Understand downloaded data sets and load them into R for analyses.</li>
</ul>
<h2 id="things-you-ll-need-to-complete-this-tutorial">Things You’ll Need To Complete This Tutorial</h2>
<p>To complete this tutorial you will need the most current version of R and,
preferably, RStudio loaded on your computer.</p>
<h3 id="install-r-packages">Install R Packages</h3>
<ul>
<li><strong>neonUtilities</strong>: Basic functions for accessing NEON data</li>
<li><strong>neonOS</strong>: Functions for common data wrangling needs for NEON observational data</li>
<li><strong>terra</strong>: Spatial data package; needed for remote sensing data</li>
</ul>
<p>These packages can be installed from CRAN:</p>
<pre><code>install.packages(&quot;neonUtilities&quot;)

install.packages(&quot;neonOS&quot;)

install.packages(&quot;terra&quot;)
</code></pre>
<h3 id="additional-resources">Additional Resources</h3>
<ul>
<li><a href="https://www.neonscience.org/neon-utilities-python" target="_blank">Tutorial for using neonUtilities from a Python environment.</a></li>
<li><a href="https://github.com/NEONScience/NEON-Utilities/neonUtilities" target="_blank">GitHub repository for neonUtilities</a></li>
<li><a href="https://www.neonscience.org/sites/default/files/cheat-sheet-neonUtilities_0.pdf" target="_blank">neonUtilities cheat sheet</a>. A quick reference guide for users.</li>
</ul>
</div>
<h2 id="getting-started-download-data-from-the-portal-and-load-packages">Getting started: Download data from the Portal and load packages</h2>
<p>Go to the
<a href="http://data.neonscience.org" target="_blank">NEON Data Portal</a>
and download some data! To follow the tutorial exactly, download
Photosynthetically active radiation (PAR) (DP1.00024.001) data from
September-November 2019 at Wind River Experimental Forest (WREF). The
downloaded file should be a zip file named NEON_par.zip.</p>
<p>If you prefer to explore a different data product, you can still follow this
tutorial. But it will be easier to understand the steps in the tutorial,
particularly the data navigation, if you choose a sensor data product for
this section.</p>
<p>Once you’ve downloaded a zip file of data from the portal, switch over to R
and load all the packages installed above.</p>
<pre><code># load packages

library(neonUtilities)

library(neonOS)

library(terra)



# Set global option to NOT convert all character variables to factors.

# If you are working in R version 4 or higher (recommended), this is 

# already the default setting.

options(stringsAsFactors=F)
</code></pre>
<h2 id="stack-the-downloaded-data-files-stackbytable">Stack the downloaded data files: stackByTable()</h2>
<p>The <code>stackByTable()</code> function will unzip and join the files in the
downloaded zip file.</p>
<pre><code># Modify the file path to match the path to your zip file

stackByTable(&quot;~/Downloads/NEON_par.zip&quot;)
</code></pre>
<p>In the same directory as the zipped file, you should now have an unzipped
folder of the same name. When you open this you will see a new folder
called <strong>stackedFiles</strong>, which should contain at least seven files:
<strong>PARPAR_30min.csv</strong>, <strong>PARPAR_1min.csv</strong>, <strong>sensor_positions.csv</strong>,
<strong>variables_00024.csv</strong>, <strong>readme_00024.txt</strong>, <strong>issueLog_00024.csv</strong>,
and <strong>citation_00024_RELEASE-202X.txt</strong>.</p>
<h2 id="navigate-data-downloads-is">Navigate data downloads: IS</h2>
<p>Let’s start with a brief description of each file. This set of files is
typical of a NEON IS data product.</p>
<ul>
<li><strong>PARPAR_30min.csv</strong>: PAR data at 30-minute averaging intervals</li>
<li><strong>PARPAR_1min.csv</strong>: PAR data at 1-minute averaging intervals</li>
<li><strong>sensor_positions.csv</strong>: The physical location of each sensor collecting PAR measurements. There is a PAR sensor at each level of the WREF tower, and this table lets you connect the tower level index to the height of the sensor in meters.</li>
<li><strong>variables_00024.csv</strong>: Definitions and units for each data field in the PARPAR_#min tables.</li>
<li><strong>readme_00024.txt</strong>: Basic information about the PAR data product.</li>
<li><strong>issueLog_00024.csv</strong>: A record of known issues associated with PAR data.</li>
<li><strong>citation_00024_RELEASE-202X.txt</strong>: The citation to use when you publish a paper using these data, in BibTeX format.</li>
</ul>
<p>We’ll explore the 30-minute data. To read the file into R, use the function
<code>readTableNEON()</code>, which uses the variables file to assign data types to each
column of data:</p>
<pre><code>par30 &lt;- readTableNEON(
  dataFile=&quot;~/Downloads/NEON_par/stackedFiles/PARPAR_30min.csv&quot;, 
  varFile=&quot;~/Downloads/NEON_par/stackedFiles/variables_00024.csv&quot;)

View(par30)
</code></pre>
<p>The first four columns are added by <code>stackByTable()</code> when it merges
files across sites, months, and tower heights. The column
<code>publicationDate</code> is the date-time stamp indicating when the data
were published, and the <code>release</code> column indicates which NEON data release
the data belong to. For more information about NEON data releases, see the
<a href="https://www.neonscience.org/data-samples/data-management/data-revisions-releases" target="_blank">Data Product Revisions and Releases</a> page.</p>
<p>Information about each data column can be found in the variables file:</p>
<pre><code>parvar &lt;- read.csv(&quot;~/Downloads/NEON_par/stackedFiles/variables_00024.csv&quot;)

View(parvar)
</code></pre>
<p>Here you can see definitions and units for each column of data.</p>
<p>Now that we know what we’re looking at, let’s plot PAR from the top
tower level. We’ll use the mean PAR from each averaging interval, and we
can see from the sensor positions file that the vertical index 080
corresponds to the highest tower level. To explore the sensor positions
data in more depth, see the <a href="https://www.neonscience.org/resources/learning-hub/tutorials/neon-spatial-data-basics" target="_blank">spatial data</a> tutorial.</p>
<pre><code>plot(PARMean~startDateTime, 
     data=par30[which(par30$verticalPosition==&quot;080&quot;),],
     type=&quot;l&quot;)
</code></pre>
<p><img src="https://raw.githubusercontent.com/NEONScience/NEON-Data-Skills/main/tutorials/R/NEON-general/neon-overview/NEON-download-explore/rfigs/plot-par-1.png" alt=" " /></p>
<p>Looks good! The sun comes up and goes down every day, and some days
are cloudy.</p>
<p>To see another layer of data, add PAR from a lower tower level to the
plot.</p>
<pre><code>plot(PARMean~startDateTime, 
     data=par30[which(par30$verticalPosition==&quot;080&quot;),],
     type=&quot;l&quot;)



lines(PARMean~startDateTime, 
     data=par30[which(par30$verticalPosition==&quot;020&quot;),],
     col=&quot;blue&quot;)
</code></pre>
<p><img src="https://raw.githubusercontent.com/NEONScience/NEON-Data-Skills/main/tutorials/R/NEON-general/neon-overview/NEON-download-explore/rfigs/plot-par-lower-1.png" alt=" " /></p>
<p>We can see there is a lot of light attenuation through the canopy.</p>
<h2 id="download-files-and-load-directly-to-r-loadbyproduct">Download files and load directly to R: loadByProduct()</h2>
<p>At the start of this tutorial, we downloaded data from the NEON data portal.
NEON also provides an API, and the <code>neonUtilities</code> packages provides methods
for downloading programmatically in R.</p>
<p>The steps we carried out above - downloading from the portal, stacking the
downloaded files, and reading in to R - can all be carried out in one step by
the neonUtilities function <code>loadByProduct()</code>.</p>
<p>To get the same PAR data we worked with above, we would run this line of code
using <code>loadByProduct()</code>:</p>
<pre><code>parlist &lt;- loadByProduct(dpID=&quot;DP1.00024.001&quot;, 
                         site=&quot;WREF&quot;, 
                         startdate=&quot;2019-09&quot;,
                         enddate=&quot;2019-11&quot;)
</code></pre>
<p>The object returned by <code>loadByProduct()</code> is a named list. The objects in the
list are the same set of tables we ended with after stacking the data from
the portal above. You can see this by checking the names of the tables in
<code>parlist</code>:</p>
<pre><code>names(parlist)

## [1] &quot;citation_00024_RELEASE-2023&quot; &quot;issueLog_00024&quot;              &quot;PARPAR_1min&quot;                
## [4] &quot;PARPAR_30min&quot;                &quot;readme_00024&quot;                &quot;sensor_positions_00024&quot;     
## [7] &quot;variables_00024&quot;
</code></pre>
<p>Now let’s walk through the details of the inputs and options in
<code>loadByProduct()</code>.</p>
<p>This function downloads data from the NEON API, merges the site-by-month
files, and loads the resulting data tables into the R environment,
assigning each data type to the appropriate R class. This is a popular
choice for NEON data users because it ensures you’re always working with
the latest data, and it ends with ready-to-use tables in R. However, if
you use it in a workflow you run repeatedly, keep in mind it will re-download
the data every time. See below for suggestions on saving the data locally.</p>
<p><code>loadByProduct()</code> works on most observational (OS) and sensor (IS) data,
but not on surface-atmosphere exchange (SAE) data, remote sensing (AOP)
data, and some of the data tables in the microbial data products. For
functions that download AOP data, see the final
section in this tutorial. For functions that work with SAE data, see
the <a href="https://www.neonscience.org/eddy-data-intro" target="_blank">NEON eddy flux data tutorial</a>.</p>
<p>The inputs to <code>loadByProduct()</code> control which data to download and how
to manage the processing:</p>
<ul>
<li><code>dpID</code>: the data product ID, e.g. DP1.00002.001</li>
<li><code>site</code>: defaults to “all”, meaning all sites with available data;
can be a vector of 4-letter NEON site codes, e.g.
<code>c(&quot;HARV&quot;,&quot;CPER&quot;,&quot;ABBY&quot;)</code>.</li>
<li><code>startdate</code> and <code>enddate</code>: defaults to NA, meaning all dates
with available data; or a date in the form YYYY-MM, e.g.
2017-06. Since NEON data are provided in month packages, finer
scale querying is not available. Both start and end date are
inclusive.</li>
<li><code>package</code>: either basic or expanded data package. Expanded data
packages generally include additional information about data
quality, such as chemical standards and quality flags. Not every
data product has an expanded package; if the expanded package is
requested but there isn’t one, the basic package will be
downloaded.</li>
<li><code>timeIndex</code>: defaults to “all”, to download all data; or the
number of minutes in the averaging interval. Only applicable to IS
data.</li>
<li><code>include.provisional</code>: T or F: should Provisional data be included in
the download? Defaults to F to return only Released data, which are
citable by a DOI and do not change over time. Provisional data are
subject to change.</li>
<li><code>check.size</code>: T or F: should the function pause before downloading
data and warn you about the size of your download? Defaults to T; if
you are using this function within a script or batch process you
will want to set it to F.</li>
<li><code>nCores</code>: Number of cores to use for parallel processing. Defaults
to 1, i.e. no parallelization.</li>
<li><code>forceParallel</code>: If the data volume to be processed does not meet
minimum requirements to run in parallel, this overrides.</li>
</ul>
<p>The <code>dpID</code> is the data product identifier of the data you want to
download. The DPID can be found on the
<a href="http://data.neonscience.org/data-products/explore" target="_blank">
Explore Data Products page</a>.
It will be in the form DP#.#####.###</p>
<p>To explore observational data, we’ll download aquatic plant chemistry data
(DP1.20063.001) from three lake sites: Prairie Lake (PRLA), Suggs Lake (SUGG),
and Toolik Lake (TOOK).</p>
<pre><code>apchem &lt;- loadByProduct(dpID=&quot;DP1.20063.001&quot;, 

                  site=c(&quot;PRLA&quot;,&quot;SUGG&quot;,&quot;TOOK&quot;), 

                  package=&quot;expanded&quot;, check.size=T)
</code></pre>
<h2 id="navigate-data-downloads-os">Navigate data downloads: OS</h2>
<p>As we saw above, the object returned by <code>loadByProduct()</code> is a named list of
data frames. Let’s check out what’s the same and what’s different from the IS
data tables.</p>
<pre><code>names(apchem)
</code></pre>
<p>As with the sensor data, we have some data tables and some metadata tables.
Most of the metadata files are the same as the sensor data: <strong>readme</strong>,
<strong>variables</strong>, <strong>issueLog</strong>, and <strong>citation</strong>. These files contain the same
type of metadata here that they did in the IS data product. Let’s look at the
other files:</p>
<ul>
<li><strong>apl_clipHarvest</strong>: Data from the clip harvest collection of aquatic plants</li>
<li><strong>apl_biomass</strong>: Biomass data from the collected plants</li>
<li><strong>apl_plantExternalLabDataPerSample</strong>: Chemistry data from the collected plants</li>
<li><strong>apl_plantExternalLabQA</strong>: Quality assurance data from the chemistry analyses</li>
<li><strong>asi_externalLabPOMSummaryData</strong>: Quality metrics from the chemistry lab</li>
<li><strong>validation_20063</strong>: For observational data, a major method for ensuring data quality is to control data entry. This file contains information about the data ingest rules applied to each input data field.</li>
<li><strong>categoricalCodes_20063</strong>: Definitions of each value for categorical data, such as growth form and sample condition</li>
</ul>
<p>You can work with these tables from the named list object, but many people find
it easier to extract each table from the list and work with it as an
independent object. To do this, use the <code>list2env()</code> function:</p>
<pre><code>list2env(apchem, .GlobalEnv)

## &lt;environment: R_GlobalEnv&gt;
</code></pre>
<p>Keep in mind that using <code>loadByProduct()</code> will re-download the data every
time you run your code. In some cases this may be desirable, but it can be
a waste of time and compute resources. To come back to these data without
re-downloading, you’ll want to save the tables locally. The most efficient
option is to save the named list as an R object.</p>
<pre><code>saveRDS(apchem, 

        &quot;~/Downloads/aqu_plant_chem.rds&quot;)
</code></pre>
<p>Then you can re-load the object to an R environment any time.</p>
<p>Other options for saving data locally:</p>
<ol>
<li>Use <code>zipsByProduct()</code> and <code>stackByTable()</code>
instead of <code>loadByProduct()</code>. With this option, use the function
<code>readTableNEON()</code> to read the files into R, to get the same column type
assignment that <code>loadByProduct()</code> carries out. Details
can be found in our <a href="https://www.neonscience.org/neonDataStackR" target="_blank">neonUtilities tutorial</a>.</li>
<li>Try out the community-developed <code>neonstore</code> package, which is designed for
maintaining a local store of the NEON data you use. The <code>neonUtilities</code>
function <code>stackFromStore()</code> works with files downloaded by <code>neonstore</code>. See
the <a href="https://www.neonscience.org/resources/learning-hub/tutorials/neonstore-stackfromstore-tutorial" target="_blank">neonstore tutorial</a>
for more information.</li>
</ol>
<p>Now let’s explore the aquatic plant data. OS data products
are simple in that the data generally tabular, and data volumes are
lower than the other NEON data types, but they are complex in that
almost all consist of multiple tables containing information collected
at different times in different ways. For example, samples collected
in the field may be shipped to a laboratory for analysis. Data
associated with the field collection will appear in one data table,
and the analytical results will appear in another. Complexity in
working with OS data usually involves bringing data together from
multiple measurements or scales of analysis.</p>
<p>As with the IS data, the variables file can tell you more about
the data.</p>
<pre><code>View(variables_20063)
</code></pre>
<p>OS data products each come with a Data Product User Guide,
which can be downloaded with the data, or accessed from the
document library on the Data Portal, or the <a href="https://data.neonscience.org/data-products/DP1.20063.001" target="_blank">Product Details</a>
page for the data product. The User Guide is designed to give
a basic introduction to the data product, including a brief
summary of the protocol and descriptions of data format and
structure.</p>
<p>To get started with the aquatic plant chemistry data, let’s
take a look at carbon isotope ratios in plants across the three
sites we downloaded. The chemical analytes are reported in the
<code>apl_plantExternalLabDataPerSample</code> table, and the table is in
long format, with one record per sample per analyte, so we’ll
subset to only the carbon isotope analyte:</p>
<pre><code>boxplot(analyteConcentration~siteID, 
        data=apl_plantExternalLabDataPerSample, 
        subset=analyte==&quot;d13C&quot;,
        xlab=&quot;Site&quot;, ylab=&quot;d13C&quot;)
</code></pre>
<p><img src="https://raw.githubusercontent.com/NEONScience/NEON-Data-Skills/main/tutorials/R/NEON-general/neon-overview/NEON-download-explore/rfigs/13C-by-site-1.png" alt=" " /></p>
<p>We see plants at Suggs and Toolik are quite low in 13C, with more
spread at Toolik than Suggs, and plants at Prairie Lake are relatively
enriched. Clearly the next question is what species these data represent.
But taxonomic data aren’t present in the <code>apl_plantExternalLabDataPerSample</code>
table, they’re in the <code>apl_biomass</code> table. We’ll need to join the two
tables to get chemistry by taxon.</p>
<p>Every NEON data product has a Quick Start Guide (QSG), and for OS
products it includes a section describing how to join the tables in the
data product. Since it’s a pdf file, <code>loadByProduct()</code> doesn’t bring it in,
but you can view the Aquatic plant chemistry QSG on the
<a href="https://data.neonscience.org/data-products/DP1.20063.001" target="_blank">Product Details</a>
page. The <code>neonOS</code> package uses the information from the QSGs to provide
an automated table-joining function, <code>joinTableNEON()</code>.</p>
<pre><code>apct &lt;- joinTableNEON(apl_biomass, 
            apl_plantExternalLabDataPerSample)
</code></pre>
<p>Using the merged data, now we can plot carbon isotope ratio
for each taxon.</p>
<pre><code>boxplot(analyteConcentration~scientificName, 
        data=apct, subset=analyte==&quot;d13C&quot;, 
        xlab=NA, ylab=&quot;d13C&quot;, 
        las=2, cex.axis=0.7)
</code></pre>
<p><img src="https://raw.githubusercontent.com/NEONScience/NEON-Data-Skills/main/tutorials/R/NEON-general/neon-overview/NEON-download-explore/rfigs/plot-13C-by-tax-1.png" alt=" " /></p>
<p>And now we can see most of the sampled plants have carbon
isotope ratios around -30, with just two species accounting
for most of the more enriched samples.</p>
<h2 id="download-remote-sensing-data-byfileaop-and-bytileaop">Download remote sensing data: byFileAOP() and byTileAOP()</h2>
<p>Remote sensing data files are very large, so downloading them
can take a long time. <code>byFileAOP()</code> and <code>byTileAOP()</code> enable
easier programmatic downloads, but be aware it can take a very
long time to download large amounts of data.</p>
<p>Input options for the AOP functions are:</p>
<ul>
<li><code>dpID</code>: the data product ID, e.g. DP1.00002.001</li>
<li><code>site</code>: the 4-letter code of a single site, e.g. HARV</li>
<li><code>year</code>: the 4-digit year to download</li>
<li><code>savepath</code>: the file path you want to download to; defaults to the
working directory</li>
<li><code>check.size</code>: T or F: should the function pause before downloading
data and warn you about the size of your download? Defaults to T; if
you are using this function within a script or batch process you
will want to set it to F.</li>
<li><code>easting</code>: <code>byTileAOP()</code> only. Vector of easting UTM coordinates whose
corresponding tiles you want to download</li>
<li><code>northing</code>: <code>byTileAOP()</code> only. Vector of northing UTM coordinates
whose corresponding tiles you want to download</li>
<li><code>buffer</code>: <code>byTileAOP()</code> only. Size in meters of buffer to include
around coordinates when deciding which tiles to download</li>
</ul>
<p>Here, we’ll download one tile of Ecosystem structure (Canopy Height
Model) (DP3.30015.001) from WREF in 2017.</p>
<pre><code>byTileAOP(&quot;DP3.30015.001&quot;, site=&quot;WREF&quot;, year=&quot;2017&quot;, check.size = T,

          easting=580000, northing=5075000, savepath=&quot;~/Downloads&quot;)
</code></pre>
<p>In the directory indicated in <code>savepath</code>, you should now have a folder
named <code>DP3.30015.001</code> with several nested subfolders, leading to a tif
file of a canopy height model tile.</p>
<h2 id="navigate-data-downloads-aop">Navigate data downloads: AOP</h2>
<p>To work with AOP data, the best bet is the <code>terra</code> package.
It has functionality for most analyses you might want to do.</p>
<p>We’ll use it to read in the tile we downloaded:</p>
<pre><code>chm &lt;- rast(&quot;~/Downloads/DP3.30015.001/neon-aop-products/2017/FullSite/D16/2017_WREF_1/L3/DiscreteLidar/CanopyHeightModelGtif/NEON_D16_WREF_DP3_580000_5075000_CHM.tif&quot;)
</code></pre>
<p>The <code>terra</code> package includes plotting functions:</p>
<pre><code>plot(chm, col=topo.colors(6))
</code></pre>
<p><img src="https://raw.githubusercontent.com/NEONScience/NEON-Data-Skills/main/tutorials/R/NEON-general/neon-overview/NEON-download-explore/rfigs/plot-aop-1.png" alt=" " /></p>
<p>Now we can see canopy height across the downloaded tile;
the tallest trees are over 60 meters, not surprising in
the Pacific Northwest. There is a clearing or clear
cut in the lower right quadrant.</p>
<h2 id="next-steps">Next steps</h2>
<p>Now that you’ve learned the basics of downloading and understanding NEON data,
where should you go to learn more? There are many more NEON tutorials to
explore, including how to align remote sensing and ground-based measurements,
a deep dive into the data quality flagging in the sensor data products, and
much more. For a recommended suite of tutorials for new users, check out
the <a href="https://www.neonscience.org/resources/learning-hub/tutorials/get-started-neon-data-series-data-tutorials" target="_blank">Getting Started with NEON Data</a>
tutorial series.</p>
</div>
<div class="include-after">
</div>
</body>
</html>
