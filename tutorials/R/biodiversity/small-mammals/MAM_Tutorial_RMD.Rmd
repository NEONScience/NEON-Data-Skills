---
syncID: TBD
title: "mammal-data-intro"
description: "This tutorial will provide an introduction to discovering, accessing and preparing NEON small mammal collection data using R"
dateCreated: 2022-12-08
authors: Sara Paull
contributors: Sara Paull
estimatedTime: 1.5 hrs
packagesLibraries: neonUtilities, dplyr
topics: data-analysis, data-visualization
languagesTool: R
dataProduct: DP1.10072.001
code1: TBD
tutorialSeries: NA
urlTitle: TBD
---

<div id="ds-objectives" markdown="1">

## Learning Objectives 
After completing this tutorial you will be able to: 

* Download NEON small mammal data. 
* Generate simple abundance metrics.
* Calculate and visualize diversity metrics

<div id="ds-objectives" markdown="1">

## Things You’ll Need To Complete This Tutorial

### R Programming Language
You will need a current version of R to complete this tutorial. We also recommend 
the RStudio IDE to work with R. 

</div>

## 1. Setup

### Load Packages
Start by installing and loading packages (if necessary) and setting 
options. Installation can be run once, then periodically to get package updates.

```{r install_packages, eval=FALSE}
* **dplyr:** `install.packages("dplyr")`
* **neonUtilities:** `install.packages("neonUtilities")`
* **neonOS:** `install.packages("neonOS")`
* **ggplot2:** `install.packages("ggplot2")`
```

<a href="/packages-in-r" target="_blank"> More on Packages in R </a>– Adapted from Software Carpentry.

Now load packages. This needs to be done every time you run code. 
We'll also set a working directory for data downloads.

```{r load-packages, , message=FALSE, warning=FALSE, results="hide"}
library(dplyr)
library(neonUtilities)
library(neonOS)
library(ggplot2)
```

### Download NEON Small Nammal Data
Download the small mammal box trapping data using the `loadByProduct()` function in
the `neonUtilities` package. Inputs needed to the function are:

* `dpID`: data product ID; woody vegetation structure = DP1.10072.001
* `site`: (vector of) 4-letter site codes; SCBI, SRER, UNDE
* `package`: basic or expanded; we'll download basic here
* `check.size`: should this function prompt the user with an estimated download size? Set to `FALSE` here for ease of processing as a script, but good to leave as default `TRUE` when downloading a dataset for the first time.

Refer to the <a href="https://www.neonscience.org/sites/default/files/cheat-sheet-neonUtilities.pdf" target="_blank">cheat sheet</a> 
for the `neonUtilities` package for more details if desired.

```{r mamdat, results="hide"}
mamdat <- loadByProduct(dpID="DP1.10072.001", 
                         site=c("SCBI", "SRER", "UNDE"),
                         package="basic", 
                         check.size = FALSE,
                        startdate = "2021-01",
                        enddate = "2022-12")
```

### Set Working Directory if Needed
If the data are not loaded directly into the R session with loadByProduct, this lesson assumes that you have set your working directory to the location of the downloaded and unzipped data subsets. 

<a href="https://www.neonscience.org/set-working-directory-r" target="_blank"> An overview
of setting the working directory in R can be found here.</a>

```{r set directory, results="hide"}
#Set working directory
#wd<-"~/data"
#setwd(wd)

```

### NEON Data Citation:
The data used in this tutorial were collected at the 
<a href="http://www.neonscience.org" target="_blank"> National Ecological Observatory Network's</a> 
<a href="/field-sites/field-sites-map" target="_blank"> field sites</a>.  

* NEON (National Ecological Observatory Network). Small mammal box trapping (DP1.10072.001). https://data.neonscience.org (accessed on `r Sys.Date()`)

## 2. Compiling the NEON Small Mammal Data
The data are downloaded into a list of separate tables. Before working with the data the tables are added to the R environment

```{r download-overview, message=FALSE, warning=FALSE}
#View all tables in the list of downloaded small mammal data:
names(mamdat)
# The categoricalCodes file provides controlled 
# lists used in the data

# The issueLog and readme have the same information that you
# will find on the data product landing page of the data portal

# The mam_perplotnight table includes the date and time for all trap setting efforts and will
# include an eventID value to indicate a unique bout of sampling in the 2023 release

#The mam_pertrapnight table includes a record for each trap set along with information about any captures and samples.

# The validation file provides the rules that constrain data upon ingest into the NEON database:

# The variables file describes each field in the returned data tables

#Extract the items from the list and add as dataframes in the R environment:
list2env(mamdat, envir=.GlobalEnv)
```

### Checking for Duplicates:
It is useful to check the two data tables for duplicate entries.  In the mam_perplotnight table this would be records with the same plot and date.  In the mam_pertrapnight table this would be records with the same nightuid, trap coordinate, and tagID.  It is worth noting that standard function cannot account for multiple captures of untagged individuals in a single trap (trapStatus = 4) and thus those should be filtered out before running the removeDups function.

```{r data download, results="hide"}
#1. check perplotnight table by nightuid using standard removeDups function
mam_plotNight_nodups <- neonOS::removeDups(data=mam_perplotnight,
                             variables=variables_10072,
                             table='mam_perplotnight')
#2. check pertrapnight table by nightuid and trapcoordinate using standard removeDups function 
mam_trapNight_multipleCaps <- mam_pertrapnight %>% filter(trapStatus == "4 - more than 1 capture in one trap" & is.na(tagID) & is.na(individualCode)) #This data subset contains no multiple captures so no further filtering is necessary

mam_trapNight_nodups <- neonOS::removeDups(data=mam_pertrapnight,
                             variables=variables_10072,
                             table='mam_pertrapnight') 
```

### Joining Tables:
The mam_perplotnight data table contains information about the trapping effort as well as an eventID that can be used to identify the bout of sampling.  These two tables can be joined so that the trapping data will include the associated eventID to group trapping sessions by bout.

```{r data join, results="hide"}
mamjn<-neonOS::joinTableNEON(mam_plotNight_nodups, mam_trapNight_nodups, name1 = "mam_perplotnight", name2 = "mam_pertrapnight")

#It is useful to verify that there are the expected number of records (the total in the pertrapnight table) and that the key variables are not blank/NA.
which(is.na(mamjn$eventID))
```

### Additional Quality Verification:
NEON data undergo quality checking and verification procedures at multiple points from the time of data entry up to the point of publication.  Nonetheless, it is considered best practice to check that the data look as they are expected to prior to completing analyses.  

For small mammal data any records that have a tagID should also have a trapStatus that includes the word 'capture'.  Before filtering the data to just the captured individuals from the target taxon it is helpful to ensure that the trapStatus is set correctly.

```{r quality checks, results="hide"}
trapStatusErrorCheck <- mam_trapNight_nodups %>% 
  filter(!is.na(tagID)) %>% 
  filter(!grepl("capture",trapStatus))
nrow(trapStatusErrorCheck)
#There are no records that have a tagID without a captured trapStatus so we can proceed using the trapStatus field to filter the data to only those traps that captured animals.
```

## 3. Calculating Minimum Number Known Alive:
The minimum number known alive (MNKA) is an index of total small mammal abundance - e.g., Norman A. Slade, Susan M. Blair, An Empirical Test of Using Counts of Individuals Captured as Indices of Population Size, Journal of Mammalogy, Volume 81, Issue 4, November 2000, Pages 1035–1045, https://doi.org/10.1644/1545-1542(2000)081<1035:AETOUC>2.0.CO;2. This approach assumes that a marked individual is present at all sampling points between its first and last capture dates, even if it wasn't actually captured in those interim trapping sessions. 

Start by generating a data table that fills in records of captures of target taxa that are not in the data but are presumed alive on a given trap-night because they were captured before and after that time-point.

```{r generate data table MNKA, message=FALSE, warning=FALSE,  results="hide"}
#1. Filter the captures down to the target taxa.  The raw table includes numerous records for opportunistic taxa that are not specifically targeted by our sampling methods.  The small mammal taxonomy table lists each taxonID as being target or not and can be used to filter to only target species.

#Read in master SMALL_MAMMAL taxon table. Use verbose = T to get taxonProtocolCategory
mam.list <- neonOS::getTaxonList(taxonType="SMALL_MAMMAL", recordReturnLimit=1000, verbose=T)

targetTaxa <- mam.list %>% filter(taxonProtocolCategory == "target") %>% select(taxonID, scientificName)

#Filter trap dataset to just the capture records of target taxa and a few core fields needed for the analyses.
coreFields <- c("nightuid", "plotID", "collectDate.x", "tagID", "taxonID", "eventID")
captures <- mamjn %>% 
  filter(grepl("capture",trapStatus) & taxonID %in% targetTaxa$taxonID) %>% 
  select(coreFields) %>%
  rename('collectDate' = 'collectDate.x')

#Next add implicit records of animals assumed present at a given sampling date because they were captured before and after that sample point.

#Generate a column of all of the unique tagIDs included in the dataset
uTags <- captures %>% select(tagID) %>% filter(!is.na(tagID)) %>% distinct()
#create empty data frame to populate
capsNew <- slice(captures,0)

#for each tagged individual, add a record for each night of trapping done on the plots on which it was captured between the first and last dates of capture
for (i in uTags$tagID){
  indiv <- captures %>% filter(tagID == i)
  firstCap <- as.Date(min(indiv$collectDate), "YYYY-MM-DD", tz = "UTC")
  lastCap <- as.Date(max(indiv$collectDate), "YYYY-MM-DD", tz = "UTC")
  possibleDates <- seq(as.Date(firstCap), as.Date(lastCap), by="days")
  potentialNights <- mam_plotNight_nodups %>% 
    filter(as.character(collectDate) %in% as.character(possibleDates) & 
                                                       plotID %in% indiv$plotID) %>% 
    select(nightuid,plotID, collectDate, eventID) %>% 
    mutate(tagID=i)
  allnights <- left_join(potentialNights, indiv)
  allnights$taxonID<-unique(indiv$taxonID)[1] #Note that taxonID sometimes changes between recaptures.  This uses only the first identification but there are a number of other ways to handle this situation.
  capsNew <- bind_rows(capsNew, allnights)
}

#check for untagged individuals and add back to the dataset if necessary:
caps_notags <- captures %>% filter(is.na(tagID))
caps_notags
```

Next create a function that takes this data table as the input to calculate the mean minimum number known alive at a given site during a particular bout of sampling. 

```{r calculate MNKA, message=FALSE, warning=FALSE}

mnka_per_site <- function(capture_data) {
  mnka_by_plot_bout <- capture_data %>% group_by(eventID,plotID) %>% 
    summarize(n=n_distinct(tagID))
    mean_mnka_by_site_bout <- mnka_by_plot_bout %>% mutate(siteID = substr(plotID, 1, 4)) %>%
      group_by(siteID, eventID) %>% 
      summarise(meanMNKA = mean(n))
      return(mean_mnka_by_site_bout)
}

MNKA<-mnka_per_site(capture_data = capsNew)
head(MNKA)
```

Make a graph to visualize the minimum number known alive across sites and years.  

```{r plotMNKA, message=FALSE, warning=FALSE}
#To estimate the minimum number known alive for each species at each bout and site it is possible to loop through and run the function for each taxonID
MNKAbysp<-data.frame()
splist<-unique(capsNew$taxonID)
for(i in 1:length(splist)){
  taxsub<-capsNew %>% filter (taxonID %in% splist[i]) %>% mutate(taxonID = splist[i])
  MNKAtax<-mnka_per_site(taxsub) %>% mutate(taxonID=splist[i], Year = substr(eventID,6,9))
  MNKAbysp<-rbind(MNKAbysp,MNKAtax)
}

#Next we will visualize the abundance flucutations for Peromyscus leucopus through time:
MNKA_PE<-MNKAbysp %>% filter(taxonID%in%"PELE")

#Create a dataframe with the first date of collection for each bout to use as the date variable when plotting
datedf<-mam_plotNight_nodups %>% 
  select(eventID, collectDate) %>% 
  group_by(eventID) %>%
  summarise(Date = min(collectDate)) %>%
  mutate(Year = substr(Date,1,4), MMDD=substr(Date,6,10))

MNKA_PE<-left_join(MNKA_PE, datedf)

PELEabunplot<-ggplot(data=MNKA_PE, aes(x=MMDD, y=meanMNKA, color=Year, group=Year)) +
  geom_point() +
  geom_line()+
  facet_wrap(~siteID) +
  theme(axis.text.x =element_text(angle=90))
#group tells ggplot which points to group together when connecting via a line.

PELEabunplot
```

Next we will look at the maximum abundance of the different species recorded at each site over the timespan of the data.

```{r plotDiversity, message=FALSE, warning=FALSE}
TaxDat<-MNKAbysp %>% 
  group_by(taxonID, siteID) %>% summarise(max=max(meanMNKA))

TaxPlot<-ggplot(TaxDat, aes(x=taxonID, y=max, fill=taxonID)) + 
  geom_bar(stat = "identity")+
  facet_wrap(~siteID, scales = 'free') +
  theme_bw()+
  theme(axis.text.x = element_text(angle=90, vjust=.5, hjust=1))

TaxPlot
```

## 5. Visualize Pathogen Prevalence Data at these Sites:

```{r pathogen data compilation, message = FALSE, warning = FALSE, results="hide"}
#First download the rodent pathogen data
rptdat <- loadByProduct(dpID="DP1.10064.002", 
                         site=c("SCBI", "SRER", "UNDE"),
                         package="basic", 
                         check.size = FALSE,
                        startdate = "2021-01",
                        enddate = "2022-12")

list2env(rptdat, envir=.GlobalEnv)

#Then check for and deal with any duplicates
rpt_pathres_nodups <- neonOS::removeDups(data=rpt2_pathogentesting,
                             variables=variables_10064,
                             table='rpt2_pathogentesting')

#Next join the pathogen data with the trapping data to get the taxonID of the individual from which the pathogen samples were taken.
#Note that joinTableNEON is not an option for the rodent tick-borne pathogen data because of the complexities involved in matching the sample IDs.  This is noted in the Table joining section of the quick start guide for tick-borne rodent pathogens on the data product landing page.
#If you attempt to use that function you will get the error: 
#Error in neonOS::joinTableNEON(mam_pertrapnight, rpt2_pathogentesting) : 
#  Tables mam_pertrapnight and rpt2_pathogentesting can't be joined automatically. Consult quick start guide for details about data relationships.
```

The information about the species from which the samples were taken is found in the small mammal trapping data.  Any analyses that will look at species will need to join the trapping data table with the pathogen data table.

```{r trapping pathogen merge, message = FALSE, warning = FALSE}
#First subset the two dataframes that will be merged to select out a smaller subset of columns to make working with the data easier:
rptdat.merge<-rpt_pathres_nodups %>% select(plotID, collectDate, sampleID, testPathogenName, testResult) %>%
  mutate(Site = substr(plotID,1,4))
mamdat.merge<-mam_trapNight_nodups %>% select(taxonID, bloodSampleID, earSampleID)

#Split the rodent pathogen data by sample types (ear or blood) before joining with the trapping data since there are 2 different columns for sampleID in the mammal trapping data - one for blood samples and one for ear samples.
rptear<-rptdat.merge %>% filter(grepl('.E', sampleID, fixed=T))
rptblood<-rptdat.merge %>% filter(grepl('.B', sampleID, fixed=T))

#Join each sample type with the correct column from the mammal trapping data.
rptear.j<-left_join(rptear, mamdat.merge, by=c("sampleID"="earSampleID"))
rptblood.j<-left_join(rptblood, mamdat.merge, by=c("sampleID"="bloodSampleID"))
rptall<-rbind(rptear.j[,-8], rptblood.j[,-8]) #combine the dataframes after getting rid of the last column whose names don't match and whose data is replaced by the sampleID column
```

Next we will summarize the prevalence of the different pathogens across sites and species and compare them visually.

```{r prevalencePlots, message = FALSE, warning = FALSE}
#Calculate the prevalence of the different pathogens in the different taxa at each site.
rptprev<-rptall %>%
  group_by(Site, testPathogenName, taxonID) %>% 
  summarise(tot.test=n(), tot.pos = sum(testResult=='Positive')) %>%
  mutate(prevalence = tot.pos/tot.test)

#Barplot of prevalence by site and pathogen name
PathPlot<-ggplot(rptprev, aes(x=testPathogenName, y=prevalence, fill=testPathogenName)) + 
  geom_bar(stat = "identity")+
  facet_wrap(~Site) +
  theme_bw()+
  theme(axis.text.x = element_text(angle=90, vjust=.5, hjust=1))
PathPlot

#SCBI seems to have a high prevalence of pathogens - let's look at the prevalence across the species examined for testing:
SCBIpathdat<-rptprev %>% filter(Site %in% 'SCBI')
SCBIPlot<-ggplot(SCBIpathdat, aes(x=testPathogenName, y=prevalence, fill=testPathogenName)) + 
  geom_bar(stat = "identity")+
  facet_wrap(~taxonID) +
  theme_bw()+
  theme(axis.text.x = element_text(angle=90, vjust=.5, hjust=1))
SCBIPlot
```


