<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
<meta name="generator" content="litedown 0.7">
<title>Content for veg structure & CHM tutorial</title>
<style type="text/css">
body {
  font-family: sans-serif;
  max-width: 800px;
  margin: auto;
  padding: 1em;
  line-height: 1.5;
  print-color-adjust: exact;
  -webkit-print-color-adjust: exact;
}
body, .abstract, code, .footnotes, footer, #refs, .caption { font-size: .9em; }
li li { font-size: .95em; }
ul:has(li > input[type="checkbox"]) { list-style: none; padding-left: 1em; }
*, :before, :after { box-sizing: border-box; }
a { color: steelblue; }
pre, img { max-width: 100%; }
pre { white-space: pre-wrap; word-break: break-word; }
pre code { display: block; padding: 1em; overflow-x: auto; }
code { font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace; }
:not(pre, th) > code, code[class], div > .caption { background: #f8f8f8; }
pre > code:is(:not([class]), .language-plain, .language-none, .plain), .box, .figure, .table { background: inherit; border: 1px solid #eee; }
pre > code {
  &.message { border-color: #9eeaf9; }
  &.warning { background: #fff3cd; border-color: #fff3cd; }
  &.error { background: #f8d7da; border-color: #f8d7da; }
}
.fenced-chunk { border-left: 1px solid #666; }
.code-fence {
  opacity: .4;
  border: 1px dashed #666;
  border-left: 2px solid;
  &:hover { opacity: inherit; }
}
.box, .figure, .table, table { margin: 1em auto; }
div > .caption { padding: 1px 1em; }
.figure { p:has(img, svg), pre:has(svg) { text-align: center; } }
.flex-col { display: flex; justify-content: space-between; }
table {
  &:only-child:not(.table > *) { margin: auto; }
  th, td { padding: 5px; font-variant-numeric: tabular-nums; }
  thead, tfoot, tr:nth-child(even) { background: whitesmoke; }
  thead th { border-bottom: 1px solid #ddd; }
  &:not(.datatable-table) {
    border-top: 1px solid #666;
    border-bottom: 1px solid #666;
  }
}
blockquote {
  color: #666;
  margin: 0;
  padding: 1px 1em;
  border-left: .5em solid #eee;
}
hr, .footnotes::before { border: 1px dashed #ddd; }
.frontmatter { text-align: center; }
#TOC {
  a { text-decoration: none; }
  ul { list-style: none; padding-left: 1em; }
  & > ul { padding: 0; }
  ul ul { border-left: 1px solid lightsteelblue; }
}
.body h2 { border-bottom: 1px solid #666; }
.body .appendix, .appendix ~ h2 { border-bottom-style: dashed; }
.main-number::after { content: "."; }
span[class^="ref-number-"] { font-weight: bold; }
.ref-number-fig::after, .ref-number-tab::after { content: ":"; }
.cross-ref-chp::before { content: "Chapter "; }
.cross-ref-sec::before { content: "Section "; }
.cross-ref-fig::before, .ref-number-fig::before { content: "Figure "; }
.cross-ref-tab::before, .ref-number-tab::before { content: "Table "; }
.cross-ref-eqn::before, .MathJax_ref:has(mjx-mtext > mjx-c + mjx-c)::before { content: "Equation "; }
.abstract, #refs {
  &::before { display: block; margin: 1em auto; font-weight: bold; }
}
.abstract::before { content: "Abstract"; text-align: center; }
#refs::before { content: "Bibliography"; font-size: 1.5em; }
.ref-paren-open::before { content: "("; }
.ref-paren-close::after { content: ")"; }
.ref-semicolon::after { content: "; "; }
.ref-and::after { content: " and "; }
.ref-et-al::after { content: " et al."; font-style: italic; }
.footnote-ref a {
  &::before { content: "["; }
  &::after { content: "]"; }
}
section.footnotes {
  margin-top: 2em;
  &::before { content: ""; display: block; max-width: 20em; }
}
.fade {
  background: repeating-linear-gradient(135deg, white, white 30px, #ddd 32px, #ddd 32px);
  opacity: 0.6;
}

@media print {
  body { max-width: 100%; }
  tr, img { break-inside: avoid; }
}
@media only screen and (min-width: 992px) {
  body:not(.pagesjs) pre:has(.line-numbers):not(:hover) { white-space: pre; }
}
</style>
</head>
<body>
<div class="frontmatter">
<div class="title"><h1>Content for veg structure &amp; CHM tutorial</h1></div>
</div>
<div class="body">
<p>An extremely common task for remote sensing researchers is to connect
remote sensing data with data on the ground. This might be a research
question in itself - what reflectance wavelengths are most closely
correlated with a particular ground feature? - or a ground-truthing for
extrapolation and prediction, or development or testing of a model.</p>
<p>This tutorial explores the relationship between a Lidar-derived canopy
height model and tree heights measured from the ground, because these
two datasets provide a straightforward introduction to thinking about
how to relate different sources of data. They are a good exemplar for
the two major components of connecting airborne and ground data:</p>
<ol>
<li>The mechanics: Finding the remotely sensed pixels that correspond to a given ground measurement</li>
<li>The science: Considering biases in each data source, and the ways the measurements might differ even if neither is incorrect</li>
</ol>
<p>We will explore these issues between these two datasets, and you can use
what you learn here as a roadmap for making similar comparisons between
different datasets.</p>
<p>The two NEON data products that estimate tree height:</p>
<ul>
<li><strong>DP3.30015.001, Ecosystem structure</strong>, aka Canopy Height Model (CHM)</li>
<li><strong>DP1.10098.001, Vegetation structure</strong></li>
</ul>
<p>The <a href="https://data.neonscience.org/data-products/DP3.30015.001" target="_blank">CHM data</a> are derived from the Lidar point cloud data collected by the remote sensing platform.
The <a href="https://data.neonscience.org/data-products/DP1.10098.001" target="_blank">vegetation structure data</a> are collected by by field staff on the ground.</p>
<p>We will be using data from the Wind River Experimental Forest (WREF) NEON
field site located in Washington state. The
predominant vegetation there is tall evergreen conifers.</p>
<div id="ds-objectives" markdown="1">
<h2 id="sec:things-you-ll-need-to-complete-this-tutorial">Things You’ll Need To Complete This Tutorial</h2>
<p>You will need the a recent version of R (4+) or Python (3.9+) loaded
on your computer to complete this tutorial.</p>
</div>
<h2 id="sec:1-setup" class="tabset">1. Setup</h2>
<p>Start by installing and loading packages (if necessary) and setting
options. Installation can be run once, then periodically to get
package updates.</p>
<h3 id="sec:r_1">R</h3>
<p>One of the packages we’ll be using, <code>geoNEON</code>, is only
available via GitHub, so it’s installed using the <code>devtools</code> package.
The other packages can be installed directly from CRAN.</p>
<pre><code>install.packages(&quot;neonUtilities&quot;)

install.packages(&quot;neonOS&quot;)

install.packages(&quot;terra&quot;)

install.packages(&quot;devtools&quot;)

devtools::install_github(&quot;NEONScience/NEON-geolocation/geoNEON&quot;)
</code></pre>
<p>Now load packages. This needs to be done every time you run code.
We’ll also set a working directory for data downloads.</p>
<pre><code>library(terra)

## terra 1.8.80

## 
## Attaching package: 'terra'

## The following object is masked from 'package:arrow':
## 
##     buffer

## The following object is masked from 'package:knitr':
## 
##     spin

library(neonUtilities)

library(neonOS)

library(geoNEON)



options(stringsAsFactors=F)



# set working directory

# adapt directory path for your system

wd &lt;- &quot;~/data&quot;
</code></pre>
<h3 id="sec:python_1">Python</h3>
<p>There are a variety of spatial packages available in Python;
we’ll use <code>rasterio</code> and <code>rioxarray</code>. We’ll also use several modules
that are installed automatically with standard Python installations.</p>
<pre><code>pip install neonutilities

pip install geopandas

pip install rasterio

pip install rioxarray

pip install rasterstats
</code></pre>
<p>Now load packages.</p>
<pre><code>import neonutilities as nu
import pandas as pd
import numpy as np
import rasterstats as rs
import geopandas as gpd
import rioxarray as rxr
import matplotlib.pyplot as plt
import matplotlib.collections
import rasterio
from rasterio import sample
from rasterio.enums import Resampling
import requests
import time
import os
</code></pre>
<h2 id="sec:_1">{-}</h2>
<h2 id="sec:2-vegetation-structure-data" class="tabset">2. Vegetation structure data</h2>
<p>In this section we’ll download the vegetation structure data,
find the locations of the mapped trees, and join to the species
and size data.</p>
<h3 id="sec:r_2">R</h3>
<p>Download the vegetation structure data using the <code>loadByProduct()</code> function in
the <code>neonUtilities</code> package. Inputs to the function are:</p>
<ul>
<li><code>dpID</code>: data product ID; woody vegetation structure = DP1.10098.001</li>
<li><code>site</code>: (vector of) 4-letter site codes; Wind River = WREF</li>
<li><code>package</code>: basic or expanded; we’ll download basic here</li>
<li><code>release</code>: which data release to download; we’ll use RELEASE-2023</li>
<li><code>check.size</code>: should this function prompt the user with an estimated download size? Set to <code>FALSE</code> here for ease of processing as a script, but good to leave as default <code>TRUE</code> when downloading a dataset for the first time.</li>
</ul>
<p>Refer to the <a href="https://www.neonscience.org/sites/default/files/cheat-sheet-neonUtilities.pdf" target="_blank">cheat sheet</a>
for the <code>neonUtilities</code> package for more details and the complete index of
possible function inputs.</p>
<pre><code>veglist &lt;- loadByProduct(dpID=&quot;DP1.10098.001&quot;, 
                         site=&quot;WREF&quot;, 
                         package=&quot;basic&quot;, 
                         release=&quot;RELEASE-2024&quot;,
                         check.size = FALSE)

## Finding available files

## Downloading files totaling approximately 26.864234 MB

## Downloading 21 files

## Unpacking zip files using 1 cores.

## Stacking data files

## Finished: Stacked 4 data tables and 5 metadata tables!

## Stacking took 1.541129 secs
</code></pre>
<h3 id="sec:python_2">Python</h3>
<p>Download the vegetation structure data using the <code>load_by_product()</code> function in
the <code>neonutilities</code> package. Inputs to the function are:</p>
<ul>
<li><code>dpid</code>: data product ID; woody vegetation structure = DP1.10098.001</li>
<li><code>site</code>: (vector of) 4-letter site codes; Wind River = WREF</li>
<li><code>package</code>: basic or expanded; we’ll download basic here</li>
<li><code>release</code>: which data release to download; we’ll use RELEASE-2023</li>
<li><code>check_size</code>: should this function prompt the user with an estimated download size? Set to <code>False</code> here for ease of processing as a script, but good to leave as default <code>True</code> when downloading a dataset for the first time.</li>
</ul>
<p>Refer to the <a href="https://www.neonscience.org/sites/default/files/cheat-sheet-neonUtilities.pdf" target="_blank">cheat sheet</a>
for the <code>neonUtilities</code> package for more details and the complete index of
possible function inputs. The cheat sheet is focused on the R package, but
nearly all the inputs are the same.</p>
<pre><code>veglist = nu.load_by_product(dpid=&quot;DP1.10098.001&quot;, 
                         site=&quot;WREF&quot;, 
                         package=&quot;basic&quot;, 
                         release=&quot;RELEASE-2024&quot;,
                         check_size = False)
</code></pre>
<h2 id="sec:_2">{-}</h2>
<h3 id="sec:get-tree-locations" class="tabset">Get tree locations</h3>
<h4 id="sec:r_3">R</h4>
<p>Use the <code>getLocTOS()</code> function in the <code>geoNEON</code> package to get
precise locations for the tagged plants. Refer to the package
documentation for more details.</p>
<pre><code>vegmap &lt;- getLocTOS(veglist$vst_mappingandtagging, 
                          &quot;vst_mappingandtagging&quot;)

## Please note locations will be calculated only for mapped woody individuals. To find subplot locations for unmapped individuals, use this function with the vst_apparentindividual, vst_non-woody, and/or vst_shrubgroup tables.

## 
## Rate limit reached. Pausing for 100 seconds to reset.
</code></pre>
<h4 id="sec:python_3">Python</h4>
<p>NEON doesn’t currently offer a Python equivalent to the <code>geoNEON</code> R
package, so we’ll calculate the tree locations step-by-step. The trees
are mapped as distance and azimuth from a reference location. The
reference location data are accessible on the NEON API. The steps in
this calculation are described in the <a href="https://data.neonscience.org/api/v0/documents/NEON_vegStructure_userGuide_vE.1" target="_blank">Data Product User Guide</a>.</p>
<p>First, get the names of the reference locations, and query the
NEON API to retrieve their location data:</p>
<pre><code>vegmapall = veglist[&quot;vst_mappingandtagging&quot;]
vegmap = vegmapall.loc[vegmapall[&quot;pointID&quot;] != &quot;&quot;]
vegmap = vegmap.reindex()
vegmap[&quot;points&quot;] = vegmap[&quot;namedLocation&quot;] + &quot;.&quot; + vegmap[&quot;pointID&quot;]
veg_points = list(set(list(vegmap[&quot;points&quot;])))

easting = []
northing = []
coord_uncertainty = []
elev_uncertainty = []
drop_points = []
for i in veg_points:
    time.sleep(1)
    vres = requests.get(&quot;https://data.neonscience.org/api/v0/locations/&quot;+i)
    vres_json = vres.json()
    if vres_json[&quot;data&quot;] is not None:
        easting.append(vres_json[&quot;data&quot;][&quot;locationUtmEasting&quot;])
        northing.append(vres_json[&quot;data&quot;][&quot;locationUtmNorthing&quot;])
        props = pd.DataFrame.from_dict(vres_json[&quot;data&quot;][&quot;locationProperties&quot;])
        cu = props.loc[props[&quot;locationPropertyName&quot;] == &quot;Value for Coordinate uncertainty&quot;][&quot;locationPropertyValue&quot;]
        coord_uncertainty.append(cu[cu.index[0]])
        eu = props.loc[props[&quot;locationPropertyName&quot;] == &quot;Value for Elevation uncertainty&quot;][&quot;locationPropertyValue&quot;]
        elev_uncertainty.append(eu[eu.index[0]])
    else:
        drop_points.append(i)

veg_points_clean = [v for v in veg_points if v not in drop_points]

ptdct = dict(points=veg_points_clean, 
             easting=easting, 
             northing=northing,
             coordinateUncertainty=coord_uncertainty,
             elevationUncertainty=elev_uncertainty)
ptfrm = pd.DataFrame.from_dict(ptdct)
ptfrm.set_index(&quot;points&quot;, inplace=True)

vegmap = vegmap.join(ptfrm, 
                     on=&quot;points&quot;, 
                     how=&quot;inner&quot;)
</code></pre>
<p>Next, use the distance and azimuth data to calculate the precise
locations of individuals, relative to the reference locations.</p>
<pre><code>vegmap[&quot;adjEasting&quot;] = (vegmap[&quot;easting&quot;]
                        + vegmap[&quot;stemDistance&quot;]
                        * np.sin(vegmap[&quot;stemAzimuth&quot;]
                                   * np.pi / 180))

vegmap[&quot;adjNorthing&quot;] = (vegmap[&quot;northing&quot;]
                        + vegmap[&quot;stemDistance&quot;]
                        * np.cos(vegmap[&quot;stemAzimuth&quot;]
                                   * np.pi / 180))
</code></pre>
<p>Add to the uncertainty estimate to account for error in measurement
from the reference location, as described in the User Guide.</p>
<pre><code>vegmap[&quot;adjCoordinateUncertainty&quot;] = vegmap[&quot;coordinateUncertainty&quot;] + 0.6
vegmap[&quot;adjElevationUncertainty&quot;] = vegmap[&quot;elevationUncertainty&quot;] + 1
</code></pre>
<h3 id="sec:_3">{-}</h3>
<h3 id="sec:combine-location-with-tree-traits" class="tabset">Combine location with tree traits</h3>
<p>Now we have the mapped locations of individuals in the <code>vst_mappingandtagging</code>
table, and the annual measurements of tree dimensions such as height and
diameter in the <code>vst_apparentindividual</code> table. To bring these measurements
together, join the two tables, using the <code>joinTableNEON()</code> function from the
<code>neonOS</code> package. Refer to the <a href="https://data.neonscience.org/data-products/DP1.10098.001" target="_blank">Quick Start Guide</a>
for Vegetation structure for more information about the data tables and the
joining instructions <code>joinTableNEON()</code> is using.</p>
<h4 id="sec:r_4">R</h4>
<pre><code>veg &lt;- joinTableNEON(veglist$vst_apparentindividual, 
                     vegmap, 
                     name1=&quot;vst_apparentindividual&quot;,
                     name2=&quot;vst_mappingandtagging&quot;)
</code></pre>
<h4 id="sec:python_4">Python</h4>
<p>Like the <code>geoNEON</code> package, there is not currently a  Python
equivalent to the <code>neonOS</code> package. Refer to the
<a href="https://data.neonscience.org/data-products/DP1.10098.001" target="_blank">Quick Start Guide</a> for Vegetation structure to find the data field to use to
join the two tables.</p>
<pre><code>veglist[&quot;vst_apparentindividual&quot;].set_index(&quot;individualID&quot;, inplace=True)
veg = vegmap.join(veglist[&quot;vst_apparentindividual&quot;],
                  on=&quot;individualID&quot;,
                  how=&quot;inner&quot;,
                  lsuffix=&quot;_MAT&quot;,
                  rsuffix=&quot;_AI&quot;)
</code></pre>
<h3 id="sec:_4">{-}</h3>
<h3 id="sec:make-a-stem-map" class="tabset">Make a stem map</h3>
<p>Let’s see what the data look like! Make a stem map, where each tree
is mapped by a circle matching its size. This won’t look informative
at the scale of the entire site, so we’ll subset to a single plot,
WREF_075.</p>
<p>In addition to looking at only one plot, we’ll also target a single
year. We want to match height measurements from the ground to remote
sensing flights, so we need to pick a year when WREF was flown.
We’ll use 2017. Use the <code>eventID</code> field from<br />
<code>vst_apparentindividual</code> to find the 2017 measurements. We use the
<code>eventID</code> rather than the <code>date</code> because sampling bouts for
vegetation structure are carried out in the winter, to avoid the
growing season, and can sometimes extend into the following
calendar year.</p>
<p>Note that in both languages the input to the function that draws a
circle is a radius, but <code>stemDiameter</code> is just that, a diameter, so
we will need to divide by two. And <code>stemDiameter</code> is in centimeters,
but the mapping scale is in meters, so we also need to divide by 100
to get the scale right.</p>
<h4 id="sec:r_5">R</h4>
<pre><code>veg2017 &lt;- veg[which(veg$eventID.y==&quot;vst_WREF_2017&quot;),]



symbols(veg2017$adjEasting[which(veg2017$plotID==&quot;WREF_075&quot;)], 
        veg2017$adjNorthing[which(veg2017$plotID==&quot;WREF_075&quot;)], 
        circles=veg2017$stemDiameter[which(veg2017$plotID==&quot;WREF_075&quot;)]/100/2, 
        inches=F, xlab=&quot;Easting&quot;, ylab=&quot;Northing&quot;)
</code></pre>
<p><img src="https://raw.githubusercontent.com/NEONScience/NEON-Data-Skills/main/tutorials/R/AOP/Lidar/lidar-topography/veg_structure_and_chm/rfigs/plot-1-1.png" alt=" " /></p>
<p>And now overlay the estimated uncertainty in the location of each stem,
in blue:</p>
<pre><code>symbols(veg2017$adjEasting[which(veg2017$plotID==&quot;WREF_075&quot;)], 
        veg2017$adjNorthing[which(veg2017$plotID==&quot;WREF_075&quot;)], 
        circles=veg2017$stemDiameter[which(veg2017$plotID==&quot;WREF_075&quot;)]/100/2, 
        inches=F, xlab=&quot;Easting&quot;, ylab=&quot;Northing&quot;)

symbols(veg2017$adjEasting[which(veg2017$plotID==&quot;WREF_075&quot;)], 
        veg2017$adjNorthing[which(veg2017$plotID==&quot;WREF_075&quot;)], 
        circles=veg2017$adjCoordinateUncertainty[which(veg2017$plotID==&quot;WREF_075&quot;)], 
        inches=F, add=T, fg=&quot;lightblue&quot;)
</code></pre>
<p><img src="https://raw.githubusercontent.com/NEONScience/NEON-Data-Skills/main/tutorials/R/AOP/Lidar/lidar-topography/veg_structure_and_chm/rfigs/plot-2-1.png" alt=" " /></p>
<h4 id="sec:python_5">Python</h4>
<pre><code>veg2017 = veg.loc[veg[&quot;eventID_AI&quot;]==&quot;vst_WREF_2017&quot;]
veg75 = veg2017.loc[veg2017[&quot;plotID_AI&quot;]==&quot;WREF_075&quot;]

fig, ax = plt.subplots()

xy = np.array(tuple(zip(veg75.adjEasting, veg75.adjNorthing)))
srad = veg75.stemDiameter/100/2
patches = [plt.Circle(center, size) for center, size in zip(xy, srad)]

coll = matplotlib.collections.PatchCollection(patches, facecolors=&quot;white&quot;, edgecolors=&quot;black&quot;)
ax.add_collection(coll)

ax.margins(0.1)
plt.show()
</code></pre>
<div class="figure">
<img src="https://raw.githubusercontent.com/NEONScience/NEON-Data-Skills/main/tutorials/R/AOP/Lidar/lidar-topography/veg_structure_and_chm/rfigs/p-plot-1-1.png" alt=" " width="672" />
<p class="caption"> </p>
</div>
<p>And now overlay the estimated uncertainty in the location of each stem,
in blue:</p>
<pre><code>fig, ax = plt.subplots()

sunc = veg75.adjCoordinateUncertainty
patchunc = [plt.Circle(center, size) for center, size in zip(xy, sunc)]

coll = matplotlib.collections.PatchCollection(patches, facecolors=&quot;None&quot;, edgecolors=&quot;black&quot;)
collunc = matplotlib.collections.PatchCollection(patchunc, facecolors=&quot;None&quot;, edgecolors=&quot;lightblue&quot;)
ax.add_collection(coll)
ax.add_collection(collunc)

ax.margins(0.1)
plt.show()
</code></pre>
<div class="figure">
<img src="https://raw.githubusercontent.com/NEONScience/NEON-Data-Skills/main/tutorials/R/AOP/Lidar/lidar-topography/veg_structure_and_chm/rfigs/p-plot-2-3.png" alt=" " width="672" />
<p class="caption"> </p>
</div>
<h3 id="sec:_5">{-}</h3>
<h2 id="sec:3-canopy-height-model-data" class="tabset">3. Canopy height model data</h2>
<p>Now we’ll download the CHM tile covering plot WREF_075. Several
other plots are also covered by this tile. We could download all tiles
that contain vegetation structure plots, but in this exercise we’re
sticking to one tile to limit download size and processing time.</p>
<p>The <code>tileByAOP()</code> function in the <code>neonUtilities</code> package allows for
download of remote sensing tiles based on easting and northing
coordinates, so we’ll give it the coordinates of all the trees in
plot WREF_075 and the data product ID, DP3.30015.001 (note that if
WREF_075 crossed tile boundaries, this code would download all
relevant tiles).</p>
<p>The download will include several metadata files as well as the data
tile. Load the data tile into the environment using the <code>terra</code> package
in R and the <code>rasterio</code> and `rioxarray`` packages in Python.</p>
<h3 id="sec:r_6">R</h3>
<pre><code>byTileAOP(dpID=&quot;DP3.30015.001&quot;, site=&quot;WREF&quot;, year=2017, 
          easting=veg2017$adjEasting[which(veg2017$plotID==&quot;WREF_075&quot;)], 
          northing=veg2017$adjNorthing[which(veg2017$plotID==&quot;WREF_075&quot;)],
          check.size=FALSE, savepath=wd)

## Downloading files totaling approximately 3.308322 MB

## Downloading 1 files

## Successfully downloaded 1 files to ~/data/DP3.30015.001

chm &lt;- rast(paste0(wd, &quot;/DP3.30015.001/neon-aop-products/2017/FullSite/D16/2017_WREF_1/L3/DiscreteLidar/CanopyHeightModelGtif/NEON_D16_WREF_DP3_580000_5075000_CHM.tif&quot;))
</code></pre>
<p>Let’s view the tile.</p>
<pre><code>plot(chm, col=topo.colors(5))
</code></pre>
<p><img src="https://raw.githubusercontent.com/NEONScience/NEON-Data-Skills/main/tutorials/R/AOP/Lidar/lidar-topography/veg_structure_and_chm/rfigs/plot-chm-1.png" alt=" " /></p>
<h3 id="sec:python_6">Python</h3>
<pre><code>nu.by_tile_aop(dpid=&quot;DP3.30015.001&quot;, site=&quot;WREF&quot;, year=&quot;2017&quot;, 
          easting=list(veg75.adjEasting), 
          northing=list(veg75.adjNorthing),
          check_size=False, savepath=os.getcwd())
</code></pre>
<p>We’ll read in versions of the tile in both <code>rasterio</code> and <code>rioxarray</code>
to enable the different data extractions we’ll need to do later in the
tutorial.</p>
<pre><code>chm = rasterio.open(os.getcwd() + &quot;/DP3.30015.001/neon-aop-products/2017/FullSite/D16/2017_WREF_1/L3/DiscreteLidar/CanopyHeightModelGtif/NEON_D16_WREF_DP3_580000_5075000_CHM.tif&quot;)

chmx = rxr.open_rasterio(os.getcwd() + &quot;/DP3.30015.001/neon-aop-products/2017/FullSite/D16/2017_WREF_1/L3/DiscreteLidar/CanopyHeightModelGtif/NEON_D16_WREF_DP3_580000_5075000_CHM.tif&quot;).squeeze()
</code></pre>
<p>Let’s view the tile.</p>
<pre><code>plt.imshow(chm.read(1))
plt.show()
</code></pre>
<div class="figure">
<img src="https://raw.githubusercontent.com/NEONScience/NEON-Data-Skills/main/tutorials/R/AOP/Lidar/lidar-topography/veg_structure_and_chm/rfigs/p-plot-chm-1.png" alt=" " width="672" />
<p class="caption"> </p>
</div>
<h2 id="sec:_6">{-}</h2>
<h2 id="sec:4-comparing-the-two-datasets">4. Comparing the two datasets</h2>
<p>Now we have the heights of individual trees measured from the ground, and
the height of the top surface of the canopy, measured from the air. There
are many different ways to make a comparison between these two
datasets! This section will walk through three different approaches.</p>
<h3 id="sec:subset-the-data" class="tabset">Subset the data</h3>
<p>First, subset the vegetation structure data to only the trees that fall
within this tile. This step isn’t strictly necessary, but it will make
the processing faster.</p>
<p>Note that although we downloaded this tile by targeting plot WREF_075,
there are other plots in the area covered by this tile - from here
forward, we’re working with all measured trees within the tile area.</p>
<h4 id="sec:r_7">R</h4>
<pre><code>vegsub &lt;- veg2017[which(veg2017$adjEasting &gt;= ext(chm)[1] &amp;
                        veg2017$adjEasting &lt;= ext(chm)[2] &amp;
                        veg2017$adjNorthing &gt;= ext(chm)[3] &amp; 
                        veg2017$adjNorthing &lt;= ext(chm)[4]),]
</code></pre>
<h4 id="sec:python_7">Python</h4>
<pre><code>vegsub = veg2017.loc[(veg2017[&quot;adjEasting&quot;] &gt;= chm.bounds[0]) &amp;
                 (veg2017[&quot;adjEasting&quot;] &lt;= chm.bounds[1]) &amp;
                 (veg2017[&quot;adjNorthing&quot;] &gt;= chm.bounds[2]) &amp; 
                 (veg2017[&quot;adjNorthing&quot;] &lt;= chm.bounds[3])]
vegsub = vegsub.reset_index(drop=True)
</code></pre>
<h3 id="sec:_7">{-}</h3>
<h3 id="sec:canopy-height-at-mapped-tree-locations" class="tabset">Canopy height at mapped tree locations</h3>
<p>Starting with a very simple first pass: get the CHM value matching
the coordinates of each mapped plant. Then make a scatter plot of
each tree’s height vs. the CHM value at its location.</p>
<h4 id="sec:r_8">R</h4>
<p>The <code>extract()</code> function from the <code>terra</code> package gets the values
from the tile at the given coordinates.</p>
<pre><code>valCHM &lt;- extract(chm, 
                  cbind(vegsub$adjEasting,
                  vegsub$adjNorthing))



plot(valCHM$NEON_D16_WREF_DP3_580000_5075000_CHM~
       vegsub$height, pch=20, xlab=&quot;Height&quot;, 
     ylab=&quot;Canopy height model&quot;)

lines(c(0,50), c(0,50), col=&quot;grey&quot;)
</code></pre>
<p><img src="https://raw.githubusercontent.com/NEONScience/NEON-Data-Skills/main/tutorials/R/AOP/Lidar/lidar-topography/veg_structure_and_chm/rfigs/no-buffer-chm-1.png" alt=" " /></p>
<p>How strong is the correlation between the ground and lidar
measurements?</p>
<pre><code>cor(valCHM$NEON_D16_WREF_DP3_580000_5075000_CHM, 
    vegsub$height, use=&quot;complete&quot;)

## [1] 0.3910897
</code></pre>
<h4 id="sec:python_8">Python</h4>
<p>The <code>sample_gen()</code> function from the <code>rasterio.sample</code> module gets
the values from the tile at the given coordinates.</p>
<pre><code>valCHM = list(sample.sample_gen(chm, 
                                tuple(zip(vegsub[&quot;adjEasting&quot;], 
                                          vegsub[&quot;adjNorthing&quot;])),
                                masked=True))

fig, ax = plt.subplots()

ax.plot((0,50), (0,50), linewidth=1, color=&quot;black&quot;)
ax.scatter(vegsub.height, valCHM, s=1)

ax.set_xlabel(&quot;Height&quot;)
ax.set_ylabel(&quot;Canopy height model&quot;)

plt.show()
</code></pre>
<div class="figure">
<img src="https://raw.githubusercontent.com/NEONScience/NEON-Data-Skills/main/tutorials/R/AOP/Lidar/lidar-topography/veg_structure_and_chm/rfigs/p-no-buffer-chm-1.png" alt=" " width="672" />
<p class="caption"> </p>
</div>
<p>How strong is the correlation between the ground and lidar
measurements?</p>
<pre><code>CHMlist = np.array([c.tolist()[0] for c in valCHM])
idx = np.intersect1d(np.where(np.isfinite(vegsub.height)), 
                     np.where(CHMlist != None))
np.corrcoef(vegsub.height[idx], list(CHMlist[idx]))[0,1]

## np.float64(0.3913279146475449)
</code></pre>
<h3 id="sec:_8">{-}</h3>
<h3 id="sec:canopy-height-within-a-buffer-of-mapped-tree-locations" class="tabset">Canopy height within a buffer of mapped tree locations</h3>
<p>Now we remember there is uncertainty in the location of each tree, so the
precise pixel it corresponds to might not be the right one. Let’s try
adding a buffer to the extraction function, to get the tallest tree within
the uncertainty of the location of each tree.</p>
<h4 id="sec:r_9">R</h4>
<pre><code>valCHMbuff &lt;- extract(chm, 
                  buffer(vect(cbind(vegsub$adjEasting,
                  vegsub$adjNorthing)),
                  width=vegsub$adjCoordinateUncertainty),
                  fun=max)



plot(valCHMbuff$NEON_D16_WREF_DP3_580000_5075000_CHM~
       vegsub$height, pch=20, xlab=&quot;Height&quot;, 
     ylab=&quot;Canopy height model&quot;)

lines(c(0,50), c(0,50), col=&quot;grey&quot;)
</code></pre>
<p><img src="https://raw.githubusercontent.com/NEONScience/NEON-Data-Skills/main/tutorials/R/AOP/Lidar/lidar-topography/veg_structure_and_chm/rfigs/buffer-chm-3.png" alt=" " /></p>
<pre><code>cor(valCHMbuff$NEON_D16_WREF_DP3_580000_5075000_CHM, 
    vegsub$height, use=&quot;complete&quot;)

## [1] 0.3846956
</code></pre>
<h4 id="sec:python_9">Python</h4>
<p>To extract values using a buffer in Python, we need to create a
shapefile of the buffered locations, and then extract the maximum
value for each area in the shapefile.</p>
<pre><code>vegloc = vegsub[[&quot;individualID&quot;,&quot;adjEasting&quot;,&quot;adjNorthing&quot;,&quot;adjCoordinateUncertainty&quot;]]
v = vegloc.rename(columns={&quot;individualID&quot;: &quot;indID&quot;, &quot;adjEasting&quot;: &quot;easting&quot;,
               &quot;adjNorthing&quot;: &quot;northing&quot;, &quot;adjCoordinateUncertainty&quot;: &quot;coordUnc&quot;},
               inplace=False)
               
gdf = gpd.GeoDataFrame(
       v, geometry=gpd.points_from_xy(v.easting, v.northing))
gdf[&quot;geometry&quot;] = gdf[&quot;geometry&quot;].buffer(distance=gdf[&quot;coordUnc&quot;])
gdf.to_file(os.getcwd() + &quot;/trees_with_buffer.shp&quot;)

## /Users/clunch/.virtualenvs/r-reticulate/lib/python3.13/site-packages/pyogrio/geopandas.py:917: UserWarning: 'crs' was not provided.  The output dataset will not have projection information defined and may not be usable in other systems.
##   write(


chm_height = rs.zonal_stats(os.getcwd() + &quot;/trees_with_buffer.shp&quot;, chmx.values, 
                            affine=chmx.rio.transform(), 
                            nodata=-9999, stats=&quot;max&quot;)

valCHMbuff = [h[&quot;max&quot;] for h in chm_height]
</code></pre>
<p>And plot the results:</p>
<pre><code>fig, ax = plt.subplots()

ax.plot((0,50), (0,50), linewidth=1, color=&quot;black&quot;)
ax.scatter(vegsub.height, valCHMbuff, s=1)

ax.set_xlabel(&quot;Height&quot;)
ax.set_ylabel(&quot;Canopy height model&quot;)

plt.show()
</code></pre>
<div class="figure">
<img src="https://raw.githubusercontent.com/NEONScience/NEON-Data-Skills/main/tutorials/R/AOP/Lidar/lidar-topography/veg_structure_and_chm/rfigs/p-plot-buffer-chm-1.png" alt=" " width="672" />
<p class="caption"> </p>
</div>
<pre><code>CHMbufflist = np.array(valCHMbuff)
idx = np.intersect1d(np.where(np.isfinite(vegsub.height)), 
                     np.where(CHMbufflist != None))
np.corrcoef(vegsub.height[idx], list(CHMbufflist[idx]))[0,1]

## np.float64(0.3848610594340662)
</code></pre>
<h3 id="sec:_9">{-}</h3>
<p>Adding the buffer has actually made our correlation slightly weaker.
Let’s think about the data.</p>
<p>There are a lot of points clustered on the 1-1 line, but there is also a
cloud of points above the line, where the measured height is lower than
the canopy height model at the same coordinates. This makes sense, because
the tree height data include the understory. There are many
plants measured in the vegetation structure data that are not at the top
of the canopy, and the CHM sees only the top surface of the canopy.</p>
<p>This also explains why the buffer didn’t improve things. Finding the
highest CHM value within the uncertainty of a tree should improve the fit
for the tallest trees, but it’s likely to make the fit worse for the
understory trees.</p>
<p>How to exclude understory plants from this analysis? Again, there are many
possible approaches. We’ll try out two, one map-centric and one
tree-centric.</p>
<h3 id="sec:compare-maximum-height-within-10-meter-pixels" class="tabset">Compare maximum height within 10 meter pixels</h3>
<p>Starting with the map-centric approach: select a pixel size, and aggregate
both the vegetation structure data and the CHM data to find the tallest point
in each pixel. Let’s try this with 10m pixels.</p>
<p>Start by rounding the coordinates of the vegetation structure data, to create
10m bins. Use <code>floor()</code> instead of <code>round()</code> so each tree ends up in the pixel
with the same numbering as the raster pixels (the rasters/pixels are
numbered by their southwest corners).</p>
<h4 id="sec:r_10">R</h4>
<pre><code>easting10 &lt;- 10*floor(vegsub$adjEasting/10)

northing10 &lt;- 10*floor(vegsub$adjNorthing/10)

vegsub &lt;- cbind(vegsub, easting10, northing10)
</code></pre>
<p>Use the <code>aggregate()</code> function to get the tallest tree in each 10m bin.</p>
<pre><code>vegbin &lt;- stats::aggregate(vegsub, 
                           by=list(vegsub$easting10, 
                                   vegsub$northing10), 
                           FUN=max)
</code></pre>
<p>To get the CHM values for the 10m bins, use the <code>terra</code> package version
of the <code>aggregate()</code> function. Let’s take a look at the lower-resolution
image we get as a result.</p>
<pre><code>CHM10 &lt;- terra::aggregate(chm, fact=10, fun=max)

plot(CHM10, col=topo.colors(5))
</code></pre>
<p><img src="https://raw.githubusercontent.com/NEONScience/NEON-Data-Skills/main/tutorials/R/AOP/Lidar/lidar-topography/veg_structure_and_chm/rfigs/CHM-10-1.png" alt=" " /></p>
<p>Use the <code>extract()</code> function again to get the values from each pixel.
Our grids are numbered by the corners, so add 5 to each tree
coordinate to make sure it’s in the correct pixel.</p>
<pre><code>vegbin$easting10 &lt;- vegbin$easting10 + 5

vegbin$northing10 &lt;- vegbin$northing10 + 5

binCHM &lt;- extract(CHM10, cbind(vegbin$easting10, 
                               vegbin$northing10))

plot(binCHM$NEON_D16_WREF_DP3_580000_5075000_CHM~
       vegbin$height, pch=20, 
     xlab=&quot;Height&quot;, ylab=&quot;Canopy height model&quot;)

lines(c(0,50), c(0,50), col=&quot;grey&quot;)
</code></pre>
<p><img src="https://raw.githubusercontent.com/NEONScience/NEON-Data-Skills/main/tutorials/R/AOP/Lidar/lidar-topography/veg_structure_and_chm/rfigs/adj-tree-coord-1.png" alt=" " /></p>
<pre><code>cor(binCHM$NEON_D16_WREF_DP3_580000_5075000_CHM, 
    vegbin$height, use=&quot;complete&quot;)

## [1] 0.3593519
</code></pre>
<h4 id="sec:python_10">Python</h4>
<pre><code>vegsub[&quot;easting10&quot;] = 10*np.floor(vegsub.adjEasting/10)
vegsub[&quot;northing10&quot;] = 10*np.floor(vegsub.adjNorthing/10)
vegsubloc = vegsub[[&quot;height&quot;,&quot;easting10&quot;,&quot;northing10&quot;]]
</code></pre>
<p>Use the <code>groupby()</code> function to get the tallest tree in each 10m bin.</p>
<pre><code>vegbin = vegsubloc.groupby([&quot;easting10&quot;, &quot;northing10&quot;]).max().add_suffix('_max').reset_index()
</code></pre>
<p>To get the CHM values for the 10m bins, use the <code>warp.reproject()</code> method
in the <code>rasterio</code> package.</p>
<pre><code>target_res = (10, 10)

with rasterio.open(os.getcwd() + &quot;/DP3.30015.001/neon-aop-products/2017/FullSite/D16/2017_WREF_1/L3/DiscreteLidar/CanopyHeightModelGtif/NEON_D16_WREF_DP3_580000_5075000_CHM.tif&quot;) as src:
     data, transform = rasterio.warp.reproject(source=src.read(),
                                src_transform=src.transform,
                                src_crs=src.crs,
                                dst_crs=src.crs,
                                dst_nodata=src.nodata,
                                dst_resolution=target_res,
                                resampling=Resampling.max)
     profile = src.profile
     profile.update(transform=transform, driver='GTiff',
                    height=data.shape[1], width=data.shape[2])

     with rasterio.open(os.getcwd() + '/CHM_10m.tif', 'w', **profile) as dst:
                    dst.write(data)

chm10 = rasterio.open(os.getcwd() + '/CHM_10m.tif')
</code></pre>
<p>Let’s take a look at the lower-resolution image we get as a result.</p>
<pre><code>plt.imshow(chm10.read(1))
plt.show()
</code></pre>
<div class="figure">
<img src="https://raw.githubusercontent.com/NEONScience/NEON-Data-Skills/main/tutorials/R/AOP/Lidar/lidar-topography/veg_structure_and_chm/rfigs/p-vegbin-plot-1.png" alt=" " width="672" />
<p class="caption"> </p>
</div>
<p>Use the <code>sample()</code> function again to get the values from the pixel
corresponding to each maximum tree height estimate.
Our grids are numbered by the corners, so add 5 to each tree
coordinate to make sure it’s in the correct pixel.</p>
<pre><code>valCHM10 = list(sample.sample_gen(chm10, tuple(zip(vegbin[&quot;easting10&quot;]+5,
                                                   vegbin[&quot;northing10&quot;]+5)),
                                                   masked=True))

fig, ax = plt.subplots()

ax.plot((0,50), (0,50), linewidth=1, color=&quot;black&quot;)
ax.scatter(vegbin.height_max, valCHM10, s=1)

ax.set_xlabel(&quot;Height&quot;)
ax.set_ylabel(&quot;Canopy height model&quot;)

plt.show()
</code></pre>
<div class="figure">
<img src="https://raw.githubusercontent.com/NEONScience/NEON-Data-Skills/main/tutorials/R/AOP/Lidar/lidar-topography/veg_structure_and_chm/rfigs/p-adj-tree-coord-3.png" alt=" " width="672" />
<p class="caption"> </p>
</div>
<pre><code>CHM10list = np.array([c.tolist()[0] for c in valCHM10])
idx = np.intersect1d(np.where(np.isfinite(vegbin.height_max)), 
                     np.where(CHM10list != None))
np.corrcoef(vegbin.height_max[idx], list(CHM10list[idx]))[0,1]

## np.float64(0.35904092842414137)
</code></pre>
<h3 id="sec:_10">{-}</h3>
<p>The understory points are thinned out substantially, but so are the rest,
and we’ve lost a lot of the shorter points. We’ve lost a lot of data
overall by going to a lower resolution.</p>
<p>Let’s try and see if we can identify the tallest trees by another approach,
using the trees as the starting point instead of map area.</p>
<h3 id="sec:find-the-top-of-canopy-trees-and-compare-to-model" class="tabset">Find the top-of-canopy trees and compare to model</h3>
<p>Start by sorting the veg structure data by height.</p>
<h4 id="sec:r_11">R</h4>
<pre><code>vegsub &lt;- vegsub[order(vegsub$height, 
                       decreasing=T),]
</code></pre>
<p>Now, for each tree, let’s estimate which nearby trees might be beneath
its canopy, and discard those points. To do this:</p>
<ol>
<li>Calculate the distance of each tree from the target tree.</li>
<li>Pick a reasonable estimate for canopy size, and discard shorter trees
within that radius. The radius I used is 0.3 times the height, based on
some rudimentary googling about Douglas fir allometry. It could definitely
be improved on!</li>
<li>Iterate over all trees.</li>
</ol>
<p>We’ll use a simple <code>for</code> loop to do this:</p>
<pre><code>vegfil &lt;- vegsub

for(i in 1:nrow(vegsub)) {
    if(is.na(vegfil$height[i]))
        next
    dist &lt;- sqrt((vegsub$adjEasting[i]-vegsub$adjEasting)^2 + 
                (vegsub$adjNorthing[i]-vegsub$adjNorthing)^2)
    vegfil$height[which(dist&lt;0.3*vegsub$height[i] &amp; 
                        vegsub$height&lt;vegsub$height[i])] &lt;- NA
}



vegfil &lt;- vegfil[which(!is.na(vegfil$height)),]
</code></pre>
<p>Now extract the raster values, as above.</p>
<pre><code>filterCHM &lt;- extract(chm, 
                     cbind(vegfil$adjEasting, 
                           vegfil$adjNorthing))

plot(filterCHM$NEON_D16_WREF_DP3_580000_5075000_CHM~
       vegfil$height, pch=20, 
     xlab=&quot;Height&quot;, ylab=&quot;Canopy height model&quot;)

lines(c(0,50), c(0,50), col=&quot;grey&quot;)
</code></pre>
<p><img src="https://raw.githubusercontent.com/NEONScience/NEON-Data-Skills/main/tutorials/R/AOP/Lidar/lidar-topography/veg_structure_and_chm/rfigs/filter-chm-1.png" alt=" " /></p>
<pre><code>cor(filterCHM$NEON_D16_WREF_DP3_580000_5075000_CHM,
    vegfil$height)

## [1] 0.8170048
</code></pre>
<h4 id="sec:python_11">Python</h4>
<pre><code>vegfil = vegsub.sort_values(by=&quot;height&quot;, ascending=False, ignore_index=True)
</code></pre>
<p>Now, for each tree, let’s estimate which nearby trees might be beneath
its canopy, and discard those points. To do this:</p>
<ol>
<li>Calculate the distance of each tree from the target tree.</li>
<li>Pick a reasonable estimate for canopy size, and discard shorter trees
within that radius. The radius I used is 0.3 times the height, based on
some rudimentary googling about Douglas fir allometry. It could definitely
be improved on!</li>
<li>Iterate over all trees.</li>
</ol>
<p>We’ll use a simple <code>for</code> loop to do this:</p>
<pre><code>height = vegfil.height.reset_index()
for i in vegfil.index:
    if height.height[i] is None:
        pass
    else:
        dist = np.sqrt(np.square(vegfil.adjEasting[i]-vegfil.adjEasting) + 
                       np.square(vegfil.adjNorthing[i]-vegfil.adjNorthing))
        idx = vegfil.index[(vegfil.height&lt;height.height[i]) &amp; (dist&lt;0.3*height.height[i])]
        height.loc[idx, &quot;height&quot;] = None
</code></pre>
<p>Now extract the raster values, as above.</p>
<pre><code>filterCHM = list(sample.sample_gen(chm, tuple(zip(vegfil[&quot;adjEasting&quot;],
                                                  vegfil[&quot;adjNorthing&quot;])),
                                                  masked=True))

fig, ax = plt.subplots()

ax.plot((0,50), (0,50), linewidth=1, color=&quot;black&quot;)
ax.scatter(height.height, filterCHM, s=1)

ax.set_xlabel(&quot;Height&quot;)
ax.set_ylabel(&quot;Canopy height model&quot;)

plt.show()
</code></pre>
<div class="figure">
<img src="https://raw.githubusercontent.com/NEONScience/NEON-Data-Skills/main/tutorials/R/AOP/Lidar/lidar-topography/veg_structure_and_chm/rfigs/p-filter-chm-1.png" alt=" " width="672" />
<p class="caption"> </p>
</div>
<pre><code>filCHMlist = np.array([c.tolist()[0] for c in filterCHM])
idx = np.intersect1d(np.where(np.isfinite(height.height)), 
                     np.where(filCHMlist != None))
np.corrcoef(height.height[idx], list(filCHMlist[idx]))[0,1]

## np.float64(0.8393670222898226)
</code></pre>
<h3 id="sec:_11">{-}</h3>
<p>This is quite a bit better! There are still several understory points we
failed to exclude, but we were able to filter out most of the understory
without losing so many overstory points.</p>
<h3 id="sec:remove-dead-trees" class="tabset">Remove dead trees</h3>
<p>Let’s try one more thing. The <code>plantStatus</code> field in the veg structure data
indicates whether a plant is dead, broken, or otherwise damaged. In theory,
a dead or broken tree can still be the tallest thing around, but it’s less
likely, and it’s also less likely to get a good Lidar return. Exclude all
trees that aren’t alive:</p>
<h4 id="sec:r_12">R</h4>
<pre><code>vegfil &lt;- vegfil[which(vegfil$plantStatus==&quot;Live&quot;),]



filterCHM &lt;- extract(chm, 
                     cbind(vegfil$adjEasting, 
                           vegfil$adjNorthing))



plot(filterCHM$NEON_D16_WREF_DP3_580000_5075000_CHM~
       vegfil$height, pch=20, 
     xlab=&quot;Height&quot;, ylab=&quot;Canopy height model&quot;)



lines(c(0,50), c(0,50), col=&quot;grey&quot;)
</code></pre>
<p><img src="https://raw.githubusercontent.com/NEONScience/NEON-Data-Skills/main/tutorials/R/AOP/Lidar/lidar-topography/veg_structure_and_chm/rfigs/live-trees-3.png" alt=" " /></p>
<pre><code>cor(filterCHM$NEON_D16_WREF_DP3_580000_5075000_CHM,
    vegfil$height)

## [1] 0.9113093
</code></pre>
<h4 id="sec:python_12">Python</h4>
<pre><code>idx = vegfil.index[vegfil.plantStatus!=&quot;Live&quot;]
height.loc[idx, &quot;height&quot;] = None

fig, ax = plt.subplots()

ax.plot((0,50), (0,50), linewidth=1, color=&quot;black&quot;)
ax.scatter(height.height, filterCHM, s=1)

ax.set_xlabel(&quot;Height&quot;)
ax.set_ylabel(&quot;Canopy height model&quot;)

plt.show()
</code></pre>
<div class="figure">
<img src="https://raw.githubusercontent.com/NEONScience/NEON-Data-Skills/main/tutorials/R/AOP/Lidar/lidar-topography/veg_structure_and_chm/rfigs/p-live-trees-1.png" alt=" " width="672" />
<p class="caption"> </p>
</div>
<pre><code>idx = np.intersect1d(np.where(np.isfinite(height.height)), 
                     np.where(filCHMlist != None))
np.corrcoef(height.height[idx], list(filCHMlist[idx]))[0,1]

## np.float64(0.9113648148226839)
</code></pre>
<h3 id="sec:_12">{-}</h3>
<p>Nice!</p>
<h3 id="sec:final-thoughts-on-intercomparison">Final thoughts on intercomparison</h3>
<p>This tutorial has explored different ways of relating remotely
sensed to ground-based data. Although some of the options we tried
resulted in stronger correlations than others, the approach you
choose will probably depend most on the research questions you are
trying to answer. The goal of this tutorial has been to help you
think through the possibilities, and identify some of the pitfalls
and biases.</p>
<p>Speaking of biases: however we slice the data, there is a noticeable
bias even in the strongly correlated values. The CHM heights are
generally a bit shorter than the ground-based estimates of tree height.
There are two biases in the CHM data that contribute to this. (1) Lidar
returns from short-stature vegetation are difficult to distinguish
from returns from the ground itself, so the “ground” estimated by Lidar
is often a bit higher than the true ground surface, and (2) the height
estimate from Lidar represents the highest return, but the highest return
may slightly miss the actual tallest point on a given tree. This is
especially likely to happen with conifers, which are the top-of-canopy
trees at Wind River.</p>
<p>Finally, as you explore other types of both remote sensing and ground
data, keep in mind that the two datasets we examined here, tree height
and canopy height model, are an unusual pair in that both are
measuring the same quantity in the same units. Attempting to relate
remote sensing and ground data can be much more complicated in other
scenarios, such as the relationships between leaf chemistry and
reflectance indices.</p>
</div>
</body>
</html>
