---
syncID: FILL IN
title: "Using the neonOS Package to Find Samples"
description: "Use the functions in the neonOS package to explore the relationships between samples in the NEON database."
dateCreated: 2022-03-29
authors: [Claire K. Lunch]
contributors: 
estimatedTime: 40 minutes
packagesLibraries: neonOS, neonUtilities
topics: data-management, rep-sci
languageTool: R
dataProduct: 
code1: FILL IN
tutorialSeries:
urlTitle: neonOS-samples-tutorial

---


## Background About Samples

The definition of a sample in the NEON data system is very broad. For 
example, at sites with woody vegetation, each tagged tree is a "sample", 
even though it never leaves the field. Leaves and other samples taken from 
a given tree are considered subsamples of the tree, and may have their 
own subsamples.

The sample system at NEON is hierarchical, meaning that any given sample 
can have both parent and child samples. These relationships are not one to 
one, each sample may have multiple parents and/or multiple children. Samples 
with multiple parents are the rarest type, and are referred to as mixtures.

Samples may be measured repeatedly over time, as in the case of trees, or they 
may be consumed or destroyed in the process of analysis, such as some water 
chemistry samples. Often, they are subsampled several times, with different 
subsamples analyzed for different purposes. A significant portion of NEON 
samples are completely or partially preserved at the NEON Biorepository, where 
they are available to the community by request for further analyses.

Like the **/taxonomy** endpoint, the **/samples** endpoint has 
multiple query options.

Going back to the `vst.maptag` data table we downloaded, the data field 
containing the sample identifiers for the individual trees is 
`individualID`. Let's look up a specific tree, an aspen, 
NEON.PLA.D10.RMNP.03861.

In order to query a sample, both a sample tag (= ID) and a sample class are 
needed. So we will first need to look up the sample tag and see which 
classes it exists in (this step is necessary because NEON sample IDs 
may be repeated in different classes, i.e. different types of samples).

```{r get-sample-class}

samp.class.req <- GET("https://data.neonscience.org/api/v0/samples/classes?sampleTag=NEON.PLA.D10.RMNP.03861")
samp.class.list <- jsonlite::fromJSON(content(samp.class.req, as="text"))
samp.class.list$data

```

There is only one possible sample class for the sample tag 
NEON.PLA.D10.RMNP.03861, `taggedPlant`. So we can proceed to query for 
sample information using the tag and class together.

```{r get-sample-view}

samp.view.req <- GET("https://data.neonscience.org/api/v0/samples/view?sampleTag=NEON.PLA.D10.RMNP.03861&sampleClass=taggedPlant")
samp.view.list <- jsonlite::fromJSON(content(samp.view.req, as="text"))
samp.view.list$data

```
