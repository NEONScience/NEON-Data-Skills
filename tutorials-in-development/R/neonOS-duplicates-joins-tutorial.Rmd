---
syncID: FILL IN
title: "Using the neonOS Package to Check for Duplicates and Join Tables"
description: "Use the functions in the neonOS package to process NEON observational data: check for duplicate data records, and join data tables."
dateCreated: 2022-03-25
authors: [Claire K. Lunch]
contributors: 
estimatedTime: 40 minutes
packagesLibraries: neonOS, neonUtilities
topics: data-management, rep-sci
languageTool: R
dataProduct: 
code1: FILL IN
tutorialSeries:
urlTitle: neonOS-duplicates-joins-tutorial

---

NEON observational data are diverse in both content and in data structure. 
Generally, data are published in a set of data tables, each of which 
corresponds to a particular activity: for example, several data 
products include a field collection data table, a sample processing 
data table, and a table of laboratory analytical results.

### Joining data tables

Depending on the analysis you want to carry out, there may be data in 
multiple tables that you want to bring together. For example, it is 
very common that species identifications are in a different table from 
chemical composition or pathogen status. For species-specific analyses, 
you would need to draw on multiple tables. There are a variety of ways 
to do this, but one of the simplest is to join the tables and create a 
single flat table.

The Quick Start Guides and Data Product User Guides provide information 
about the relationships between different data tables, and we 
recommend you consult these documents for the data products you are 
working with to gain the full picture. For the step of joining related 
tables, the `neonOS` package provides the `joinTableNEON()` function, 
which will join tables if their relationship is sufficiently simple, 
and will provide an informative message if this is not possible, or if 
customized code is required.

### Duplicates

One of the most common data entry errors that occurs in NEON OS data is 
duplicate entry. NEON data entry applications and ingest validation rules 
are designed to prevent duplicate entry where possible, but errors can't 
be avoided completely. Consequently, NEON metadata for each OS data product 
(the variables file) includes an indicator of which data fields, taken 
together, should define a unique record. The `neonOS` function `removeDups()` 
uses these metadata to identify duplicate records. Depending on the content 
of the duplicate records, they may be resolved to a single record or 
marked as unresolvable - see below for details.

In this tutorial, we will de-duplicate and then join two data tables in the 
Aquatic plant bryophyte chemical properties (DP1.20063.001) data product, 
using it as an example to demonstrate the operation of these two functions. 
Then we will take a look at Mosquitoes sampled from CO2 traps (DP1.10043.001), 
which contains more complicated table relationships, and see how to modify 
the code to work with those tables.


<div id="ds-objectives" markdown="1">

## Objectives
After completing this activity, you will be able to:

 * Identify and resolve duplicate data using the `neonOS` package 
 * Join NEON data tables using the `neonOS` package 

## Things Youâ€™ll Need To Complete This Tutorial
You will need a version of R (4.0 or higher. This code may work with 
earlier versions but it hasn't been tested) and, preferably, `RStudio` 
loaded on your computer to complete this tutorial.

### Install R Packages

* **neonUtilities:** `install.packages("neonUtilities")`
* **neonOS**: `devtools::install_github("NEONScience/NEON-OS-data-processing/neonOS")`

## Additional Resources

* NEON <a href="http://data.neonscience.org" target="_blank"> Data Portal </a>
* <a href="https://www.neonscience.org/resources/code-hub" target="_blank">NEON Code Hub</a>

</div>


## Set Up R Environment and Download Data

First install and load the necessary packages.

```{r setup, eval=c(9,10,11), results="hide"}

# install packages. can skip this step if already installed
# update neonOS installation after CRAN release
install.packages("neonUtilities")
install.packages("ggplot2")
devtools::install_github("NEONScience/NEON-OS-data-processing/neonOS")

# load packages
library(neonUtilities)
library(neonOS)
library(ggplot2)

```

We'll use aquatic plant chemistry (DP1.20063.001) as the example dataset. Use 
the `neonUtilities` function `loadByProduct()` to download and read in the 
data. If you're not familiar with the `neonUtilities` package and how to use 
it to access NEON data, we recommend you follow the <a href="https://www.neonscience.org/resources/learning-hub/tutorials/download-explore-neon-data" target="_blank">Download and Explore NEON Data</a> 
tutorial before proceeding with this one.

Here, we'll use the same subset of aquatic plant chemistry data as in the 
Download and Explore tutorial. Get the data from the Prairie Lake, Suggs Lake, 
and Toolik Lake sites, specifying the 2022 data release.

``` {r load-data, results="hide"}

apchem <- loadByProduct(dpID="DP1.20063.001", 
                        site=c("PRLA","SUGG","TOOK"), 
                        package="expanded",
                        release="RELEASE-2022",
                        check.size=F)

```

Copy each of the downloaded tables into the R environment.

``` {r env, results="hide"}

list2env(apchem, .GlobalEnv)

```


## Identify and Resolve Duplicates

As noted above, duplicate data entry is a common error in human 
data entry. `removeDups()` uses the definitional metadata in the 
variables file to identify duplicates. It requires two inputs: 
the data table, and the corresponding variables file.

``` {r remove-dups-biomass}

apl_biomass <- removeDups(data=apl_biomass, 
                          variables=variables_20063)

```

There were no duplicates found in the `apl_biomass` data table. 
A `duplicateRecordQF` quality flag has been added to the table, 
and you can confirm that there were no duplicates by checking 
the values of the flag.

``` {r view-flag-values}

unique(apl_biomass$duplicateRecordQF)

```

All data have flag value = 0, indicating they are not duplicated. 
Let's check the `apl_plantExternalLabDataPerSample` table.

``` {r remove-dups-analytes, results="hide"}

apl_plantExternalLabDataPerSample <- removeDups(
  data=apl_plantExternalLabDataPerSample, 
  variables=variables_20063)

```

```
10 duplicated key values found, representing 20 non-unique records. Attempting to resolve.
  |==========================================================================================| 100%
2 resolveable duplicates merged into matching records
2 resolved records flagged with duplicateRecordQF=1
16 unresolveable duplicates flagged with duplicateRecordQF=2
```

The function output tells you there were 20 duplicates (out of 26108 
total data records). Four of those duplicates were resolved, leaving two 
records flagged as resolved duplicates, with `duplicateRecordQF=1`. The 
remaining 16 couldn't be resolved, and were flagged with 
`duplicateRecordQF=2`.

What does it mean for duplicates to be resolved? Some duplicates represent 
identical data that have been entered multiple times, whereas some duplicates 
have the same values in the primary key, but differ in data values. 
`removeDups()` has a fairly narrow set of criteria for resolving to a single 
record:

1. If one data record has empty fields that are populated in the other record, the non-empty values are retained.
2. If records are identical except for uid, remarks, and/or personnel (`identifiedBy`, `recordedBy`, etc) fields, unique values are concatenated within the non-matching fields, separated by `|` (pipes).

Records that can be merged to a single record by these criteria are flagged 
with `duplicateRecordQF=1`. Records with mis-matched data that can't be merged 
are retained as-is and flagged with `duplicateRecordQF=2`.

Note that even in fully identical duplicates, the uid field will always be 
unique. Thus the uid field in merged records will always contain the 
pipe-delimited set of uids of the original records.

What does this look like in practice? Let's look at the two resolved 
duplicates:

``` {r view-resolved}

apl_plantExternalLabDataPerSample[which(
  apl_plantExternalLabDataPerSample$duplicateRecordQF==1),]

```

You can see that both records have two pipe-delimited uids, and are 
flagged.

Let's look at the unresolveable duplicates:

``` {r view-unresolved}

apl_plantExternalLabDataPerSample[which(
  apl_plantExternalLabDataPerSample$duplicateRecordQF==2),]

```

The key for this data table is the sample identifier and analyte, and 
here there are multiple records with the same sample identifier, both for 
carbon and nitrogen values. The most likely scenario is that these are 
unlabeled replicate analyses, i.e., the lab ran multiple analyses on the 
same samples for quality control purposes, but forgot to label them 
accordingly.

Now, how should you proceed with your analysis? Of course, that is up to 
you, and depends on your analysis. Because these appear to be unlabeled 
analytical replicates, I would probably average the analyte values, but 
a decision like this can't be made automatically - `removeDups()` can 
identify the records of concern, but what to do with them is a 
judgement call.

Of course, NEON scientists also review NEON data and identify 
duplicates as part of quality assurance and quality control procedures, 
and resolve them if possible. In the data download step above, we 
accessed RELEASE-2022. The data release is stable and reproducible over 
time, but these duplicates may be resolved in future releases of these 
data.

## Join Data Tables

If you are using `neonOS` to check for duplicates and also to join data 
tables, the duplicate step should always come first. Because duplicate 
identification uses the variables file to determine uniqueness of data 
records, the duplicate check step requires that the data match the 
variables file exactly, which they won't after being joined.

To join the `apl_biomass` and `apl_plantExternalLabDataPerSample` tables, 
we input both tables to the `joinTableNEON()` function. It uses the 
information provided in NEON quick start guides to determine whether the 
join is possible, and if it is, which fields to use to perform the join.

```{r join, results="hide"}

aqbc <- joinTableNEON(apl_biomass,
                      apl_plantExternalLabDataPerSample)

```

After joining tables, always take a look at the resulting table and 
make sure it makes sense. Errors in joining can easily result in 
completely nonsensical data.

When checking your results, keep in mind that the default behavior of 
`joinTableNEON()` is a full join, i.e., all records from both original 
tables are retained, even if they don't match. For a small number of 
table pairs, the Quick Start Guide specifies a left join.

### Table-joining pitfalls

The risks and potential errors discussed in this section are general 
concerns, not specific to NEON data. You can skip this section if 
you're familiar with navigating relational tables.

I always start by checking the number of rows, and comparing to the 
numbers of rows in the two original tables. Let's walk through each 
of the possible outcomes, and what they might indicate, where j is the 
number of rows in the joined table, and n1 and n2 are the number of 
rows in each of the original tables:

#### j = n1 or j = n2
This is generally a good sign! Each of the records in one of the 
tables had one or more matches from the other table. Look in the 
data table to verify this is true.

#### n1 + n2 > j > max(n1, n2)
Generally this means either some records had multiple matches between 
the two tables, or some records didn't match. The former can happen if 
there are unresolved duplicates in both tables, turning 2 records 
from each table into 4 in the joined table, and the latter can happen 
if there are key values present in one table and absent in the other. 
For example, in NEON data, there can be field data records noting days 
when sampling was attempted, but wasn't possible due to local conditions, 
such as flooding. These records don't have corresponding analytical data, 
because no samples were collected.

#### j = n1 + n2
Usually this happens when the key fields used to perform the join are 
incorrect, and there are no matches between the two tables. In the data, 
you'll see a block of data with columns from the first table and blanks 
from the second table, appended to a block of data with columns from the 
second table and blanks from the first table. If this happens with NEON 
data, check your code for errors, then contact NEON to correct the Quick 
Start Guide.

#### j > n1 + n2
This can be possible in rare circumstances, but usually it indicates a 
problem. Records consistently found multiple matches between the two 
tables, resulting in multiplication of the number of rows. This can 
happen if, for example, two long-format tables are joined together, each 
containing records for several analytes from a single sample. The sample 
is the key, but since it has records for (say), carbon, nitrogen, and 
phosphorus in one table, and the corresponding isotopes in the other, 
each record has 3 matches in the other table, and vice versa. In 
situations like this, it's much better to filter or re-structure your 
data before joining.

If your join results seem suspicious, filter down to a small number of 
records in each table, e.g. records from a single sampling event at a 
single site. Inspecting the join results visually for this smaller set 
should be informative - are there large numbers of blanks where values 
from one of the tables should be? Are values from one of the tables 
frequently duplicated in unexpected ways? Make sure you understand how 
the values from each table are lined up before proceeding with your 
analysis.

### Checking the aquatic plant table join




SOME KIND OF FIGURE HERE??

## Other Input Options

After downloading the data above, we ran `list2env()` to make each table 
an independent object in the R environment, and then provided the tables 
to the two functions as-is. This worked because the names of the objects 
were identical to the table names, so the functions were able to figure 
out which tables they were. If the object names are not exactly equal to 
the table names, you will need to input the table names separately. If 
we hadn't used `list2env()`, this is how we would proceed:

```{r with-table-names, results="hide"}

bio.dup <- removeDups(data=apchem$apl_biomass,
                      variables=apchem$variables_20063,
                      table="apl_biomass")
chem.dup <- removeDups(data=apchem$apl_plantExternalLabDataPerSample,
                      variables=apchem$variables_20063,
                      table="apl_plantExternalLabDataPerSample")
aq.join <- joinTableNEON(table1=bio.dup, 
                         table2=chem.dup,
                         name1="apl_biomass",
                         name2="apl_plantExternalLabDataPerSample")

```

## More Complicated Table Joins

In the aquatic plant chemistry example, we were able to join two tables 
in a single step. In some cases, the relationship between tables is 
more complicated, and joining is more difficult. In these cases, 
`joinTableNEON()` will provide an error message, and usually direct 
you to the Quick Start Guide for more information. Let's walk through 
how you can use this information, using Mosquitoes sampled from CO2 traps 
(DP1.10043.001) from Toolik Lake as an example.

```{r load-mos, results="hide"}

mos <- loadByProduct(dpID="DP1.10043.001",
                     site="TOOL", 
                     release="RELEASE-2022",
                     check.size=F)
list2env(mos, .GlobalEnv)

```

Let's say we're interested in evaluating which mosquito species are found in 
which vegetation types. The species identifications are in the 
`mos_expertTaxonomistIDProcessed` table, and the trapping conditions are in 
the `mos_trapping` table. So we'll attempt to join those two tables.

```{r try-join-mos, results="hide"}

mos.sp <- joinTableNEON(mos_trapping,
                        mos_expertTaxonomistIDProcessed)

```

```
Error in joinTableNEON(mos_trapping, mos_expertTaxonomistIDProcessed) : 
  Tables mos_trapping and mos_expertTaxonomistIDProcessed can't be joined directly, but can each be joined to a common table(s). Consult quick start guide for details.
```

The function returns an error, telling us it can't perform a simple join 
on the two tables, but there is a table they can each join to, which can be 
used to join them indirectly. As directed, we refer to the Quick Start Guide 
for DP1.10043.001, where we learn that `mos_sorting` is the intermediate 
table required.

First, let's join `mos_trapping` and `mos_sorting`:

```{r join-trap-sort, results="hide"}

mos.trap <- joinTableNEON(mos_trapping,
                          mos_sorting)

```

Now, this next step is a bit odd. We've created a merged table of 
`mos_trapping` and `mos_sorting`, but we know 
`mos_expertTaxonomistIDProcessed` can only join to `mos_sorting`. So 
we pass the merged table to `joinTableNEON()`, telling the function to 
use the join instructions for `mos_sorting` and 
`mos_expertTaxonomistIDProcessed`.

```{r join-sort-tax, results="hide"}

mos.tax <- joinTableNEON(mos.trap,
                         mos_expertTaxonomistIDProcessed,
                         name1="mos_sorting")

```

When you join data in this way, check carefully that the resulting 
table is structured logically and contains the data you expect it to. 
Looking at the merged table, we now have multiple records for each 
trapping event, with one record for each species captured in that event, 
plus a set of records for traps that either caught no mosquitoes or 
couldn't be deployed, and thus have no species identifications. This 
is consistent with the table join we performed, so everything appears 
to be correct.

Let's take a look at species occurrence by habitat, as we set out to 
do:

```{r mos-fig}

gg <- ggplot(mos.tax, 
             aes(scientificName, individualCount, 
                 group=scientificName, 
                 color=scientificName)) +
             geom_boxplot() + 
        facet_wrap(~nlcdClass) +
        theme(axis.text.x=element_blank())
gg

```




